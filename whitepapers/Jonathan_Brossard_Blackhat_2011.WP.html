<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META http-equiv="X-UA-Compatible" content="IE=8">
<title>Jonathan Brossard Blackhat 2011.WP</title>
<link rel="canonical" href="https://moabi.com/research/jbrossard/whitepapers/Jonathan_Brossard_Blackhat_2011.WP.html" />
<STYLE type="text/css">

body {margin-top: 0px;margin-left: 0px;}

#page_1 {position:relative; overflow: hidden;margin: 97px 0px 131px 96px;padding: 0px;border: none;width: 720px;}
#page_1 #id1_1 {border:none;margin: 0px 0px 0px 38px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_1 #id1_2 {border:none;margin: 107px 0px 0px 4px;padding: 0px;border:none;width: 716px;overflow: hidden;}

#page_1 #p1dimg1 {position:absolute;top:809px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_1 #p1dimg1 #p1img1 {width:76px;height:1px;}




#page_2 {position:relative; overflow: hidden;margin: 97px 0px 136px 134px;padding: 0px;border: none;width: 682px;}





#page_3 {position:relative; overflow: hidden;margin: 92px 0px 93px 96px;padding: 0px;border: none;width: 720px;}
#page_3 #id3_1 {border:none;margin: 0px 0px 0px 4px;padding: 0px;border:none;width: 716px;overflow: hidden;}
#page_3 #id3_2 {border:none;margin: 29px 0px 0px 309px;padding: 0px;border:none;width: 411px;overflow: hidden;}

#page_3 #p3dimg1 {position:absolute;top:799px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_3 #p3dimg1 #p3img1 {width:76px;height:1px;}




#page_4 {position:relative; overflow: hidden;margin: 97px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_4 #id4_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_4 #id4_2 {border:none;margin: 197px 0px 0px 271px;padding: 0px;border:none;width: 411px;overflow: hidden;}





#page_5 {position:relative; overflow: hidden;margin: 97px 0px 93px 96px;padding: 0px;border: none;width: 720px;}
#page_5 #id5_1 {border:none;margin: 0px 0px 0px 4px;padding: 0px;border:none;width: 716px;overflow: hidden;}
#page_5 #id5_2 {border:none;margin: 25px 0px 0px 309px;padding: 0px;border:none;width: 411px;overflow: hidden;}

#page_5 #p5dimg1 {position:absolute;top:750px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_5 #p5dimg1 #p5img1 {width:76px;height:1px;}




#page_6 {position:relative; overflow: hidden;margin: 97px 0px 93px 96px;padding: 0px;border: none;width: 720px;}
#page_6 #id6_1 {border:none;margin: 0px 0px 0px 4px;padding: 0px;border:none;width: 716px;overflow: hidden;}
#page_6 #id6_2 {border:none;margin: 26px 0px 0px 309px;padding: 0px;border:none;width: 411px;overflow: hidden;}

#page_6 #p6dimg1 {position:absolute;top:780px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_6 #p6dimg1 #p6img1 {width:76px;height:1px;}




#page_7 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_7 #id7_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_7 #id7_2 {border:none;margin: 23px 0px 0px 271px;padding: 0px;border:none;width: 411px;overflow: hidden;}





#page_8 {position:relative; overflow: hidden;margin: 92px 0px 93px 96px;padding: 0px;border: none;width: 720px;}
#page_8 #id8_1 {border:none;margin: 0px 0px 0px 4px;padding: 0px;border:none;width: 716px;overflow: hidden;}
#page_8 #id8_2 {border:none;margin: 23px 0px 0px 309px;padding: 0px;border:none;width: 411px;overflow: hidden;}

#page_8 #p8dimg1 {position:absolute;top:814px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_8 #p8dimg1 #p8img1 {width:76px;height:1px;}




#page_9 {position:relative; overflow: hidden;margin: 97px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_9 #id9_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_9 #id9_2 {border:none;margin: 63px 0px 0px 271px;padding: 0px;border:none;width: 411px;overflow: hidden;}





#page_10 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_10 #id10_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_10 #id10_2 {border:none;margin: 105px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_11 {position:relative; overflow: hidden;margin: 92px 0px 131px 96px;padding: 0px;border: none;width: 720px;}

#page_11 #p11dimg1 {position:absolute;top:814px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_11 #p11dimg1 #p11img1 {width:76px;height:1px;}




#page_12 {position:relative; overflow: hidden;margin: 97px 0px 93px 96px;padding: 0px;border: none;width: 720px;}
#page_12 #id12_1 {border:none;margin: 0px 0px 0px 4px;padding: 0px;border:none;width: 716px;overflow: hidden;}
#page_12 #id12_2 {border:none;margin: 38px 0px 0px 305px;padding: 0px;border:none;width: 415px;overflow: hidden;}

#page_12 #p12dimg1 {position:absolute;top:794px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_12 #p12dimg1 #p12img1 {width:76px;height:1px;}




#page_13 {position:relative; overflow: hidden;margin: 92px 0px 93px 96px;padding: 0px;border: none;width: 720px;}
#page_13 #id13_1 {border:none;margin: 0px 0px 0px 4px;padding: 0px;border:none;width: 716px;overflow: hidden;}
#page_13 #id13_2 {border:none;margin: 29px 0px 0px 305px;padding: 0px;border:none;width: 415px;overflow: hidden;}

#page_13 #p13dimg1 {position:absolute;top:799px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_13 #p13dimg1 #p13img1 {width:76px;height:1px;}




#page_14 {position:relative; overflow: hidden;margin: 92px 0px 93px 95px;padding: 0px;border: none;width: 721px;}
#page_14 #id14_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 721px;overflow: hidden;}
#page_14 #id14_2 {border:none;margin: 23px 0px 0px 306px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_15 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_15 #id15_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_15 #id15_2 {border:none;margin: 42px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_16 {position:relative; overflow: hidden;margin: 97px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_16 #id16_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_16 #id16_2 {border:none;margin: 111px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_17 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_17 #id17_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_17 #id17_2 {border:none;margin: 25px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_18 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_18 #id18_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_18 #id18_2 {border:none;margin: 29px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_19 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_19 #id19_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_19 #id19_2 {border:none;margin: 35px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_20 {position:relative; overflow: hidden;margin: 92px 0px 93px 96px;padding: 0px;border: none;width: 720px;}
#page_20 #id20_1 {border:none;margin: 0px 0px 0px 13px;padding: 0px;border:none;width: 707px;overflow: hidden;}
#page_20 #id20_2 {border:none;margin: 28px 0px 0px 305px;padding: 0px;border:none;width: 415px;overflow: hidden;}

#page_20 #p20dimg1 {position:absolute;top:814px;left:0px;z-index:-1;width:76px;height:1px;font-size: 1px;line-height:nHeight;}
#page_20 #p20dimg1 #p20img1 {width:76px;height:1px;}




#page_21 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_21 #id21_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_21 #id21_2 {border:none;margin: 28px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_22 {position:relative; overflow: hidden;margin: 92px 0px 93px 95px;padding: 0px;border: none;width: 721px;}
#page_22 #id22_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 721px;overflow: hidden;}
#page_22 #id22_2 {border:none;margin: 23px 0px 0px 306px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_23 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_23 #id23_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 496px;overflow: hidden;}
#page_23 #id23_2 {border:none;margin: 150px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_24 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_24 #id24_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_24 #id24_2 {border:none;margin: 28px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_25 {position:relative; overflow: hidden;margin: 97px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_25 #id25_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 548px;overflow: hidden;}
#page_25 #id25_2 {border:none;margin: 32px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_26 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_26 #id26_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_26 #id26_2 {border:none;margin: 42px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_27 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_27 #id27_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_27 #id27_2 {border:none;margin: 29px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_28 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_28 #id28_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_28 #id28_2 {border:none;margin: 42px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_29 {position:relative; overflow: hidden;margin: 97px 0px 93px 95px;padding: 0px;border: none;width: 721px;}
#page_29 #id29_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 721px;overflow: hidden;}
#page_29 #id29_2 {border:none;margin: 23px 0px 0px 306px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_30 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_30 #id30_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_30 #id30_2 {border:none;margin: 25px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





#page_31 {position:relative; overflow: hidden;margin: 92px 0px 93px 134px;padding: 0px;border: none;width: 682px;}
#page_31 #id31_1 {border:none;margin: 0px 0px 0px 0px;padding: 0px;border:none;width: 682px;overflow: hidden;}
#page_31 #id31_2 {border:none;margin: 467px 0px 0px 267px;padding: 0px;border:none;width: 415px;overflow: hidden;}





.ft0{font: 12px 'Arial';line-height: 15px;}
.ft1{font: 12px 'PMingLiU';line-height: 12px;}
.ft2{font: 12px 'Gabriola';line-height: 17px;}
.ft3{font: 12px 'Gabriola';line-height: 15px;}
.ft4{font: 12px 'Gabriola';line-height: 20px;}
.ft5{font: 12px 'Gabriola';line-height: 22px;}
.ft6{font: 12px 'Arial';line-height: 15px;position: relative; bottom: 5px;}
.ft7{font: 12px 'Gabriola';text-decoration: underline;line-height: 22px;}
.ft8{font: 9px 'Arial';line-height: 12px;}
.ft9{font: 12px 'Gabriola';margin-left: 4px;line-height: 22px;}
.ft10{font: 12px 'Gabriola';line-height: 12px;}
.ft11{font: 1px 'Gabriola';line-height: 1px;}
.ft12{font: 12px 'Gabriola';margin-left: 18px;line-height: 17px;}
.ft13{font: 12px 'Gabriola';line-height: 18px;}
.ft14{font: 12px 'Gabriola';margin-left: 4px;line-height: 15px;}
.ft15{font: 12px 'Gabriola';margin-left: 3px;line-height: 22px;}
.ft16{font: 12px 'Gabriola';margin-left: 5px;line-height: 22px;}
.ft17{font: 12px 'Gabriola';margin-left: 4px;line-height: 18px;}
.ft18{font: 12px 'Arial';margin-left: 18px;line-height: 15px;}
.ft19{font: 12px 'Gabriola';line-height: 19px;}
.ft20{font: 12px 'Gabriola';line-height: 21px;}
.ft21{font: 12px 'Arial';margin-left: 16px;line-height: 15px;}
.ft22{font: 12px 'Gabriola';margin-left: 4px;line-height: 17px;}
.ft23{font: 12px 'Gabriola';line-height: 16px;}
.ft24{font: 12px 'Gabriola';line-height: 14px;}
.ft25{font: 12px 'Gabriola';margin-left: 6px;line-height: 15px;}
.ft26{font: 12px 'Gabriola';margin-left: 7px;line-height: 14px;}
.ft27{font: 12px 'Gabriola';margin-left: 7px;line-height: 17px;}
.ft28{font: 12px 'Gabriola';margin-left: 6px;line-height: 14px;}
.ft29{font: 12px 'Gabriola';margin-left: 6px;line-height: 17px;}
.ft30{font: 12px 'Gabriola';margin-left: 16px;line-height: 17px;}
.ft31{font: 9px 'Arial';text-decoration: line-through;line-height: 12px;}
.ft32{font: 12px 'Gabriola';text-decoration: line-through;margin-left: 4px;line-height: 22px;}
.ft33{font: 12px 'Gabriola';margin-left: 6px;line-height: 22px;}
.ft34{font: 12px 'MS PGothic';line-height: 12px;}
.ft35{font: 12px 'Gabriola';margin-left: 6px;line-height: 16px;}
.ft36{font: 12px 'Gabriola';margin-left: 6px;line-height: 20px;}
.ft37{font: 12px 'Gabriola';text-decoration: line-through;margin-left: 4px;line-height: 17px;}
.ft38{font: 12px 'Gabriola';margin-left: 7px;line-height: 22px;}
.ft39{font: 12px 'Gabriola';margin-left: 7px;line-height: 15px;}

.p0{text-align: left;padding-left: 72px;margin-top: 0px;margin-bottom: 0px;}
.p1{text-align: left;padding-left: 100px;margin-top: 26px;margin-bottom: 0px;}
.p2{text-align: left;padding-left: 112px;margin-top: 11px;margin-bottom: 0px;}
.p3{text-align: left;padding-left: 136px;margin-top: 26px;margin-bottom: 0px;}
.p4{text-align: left;padding-left: 79px;margin-top: 12px;margin-bottom: 0px;}
.p5{text-align: justify;padding-right: 134px;margin-top: 120px;margin-bottom: 0px;}
.p6{text-align: justify;padding-right: 134px;margin-top: 14px;margin-bottom: 0px;}
.p7{text-align: justify;padding-right: 134px;margin-top: 18px;margin-bottom: 0px;}
.p8{text-align: justify;padding-right: 134px;margin-top: 9px;margin-bottom: 0px;}
.p9{text-align: justify;padding-right: 134px;margin-top: 22px;margin-bottom: 0px;}
.p10{text-align: left;margin-top: 0px;margin-bottom: 0px;}
.p11{text-align: left;padding-left: 192px;margin-top: 0px;margin-bottom: 0px;}
.p12{text-align: left;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p13{text-align: left;padding-left: 8px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p14{text-align: right;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p15{text-align: left;padding-left: 7px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p16{text-align: left;padding-left: 34px;margin-top: 0px;margin-bottom: 0px;}
.p17{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 22px;margin-bottom: 0px;}
.p18{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 21px;margin-bottom: 0px;}
.p19{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 12px;margin-bottom: 0px;}
.p20{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 23px;margin-bottom: 0px;}
.p21{text-align: left;padding-left: 34px;margin-top: 12px;margin-bottom: 0px;}
.p22{text-align: left;padding-left: 34px;padding-right: 134px;margin-top: 5px;margin-bottom: 0px;}
.p23{text-align: left;padding-left: 34px;padding-right: 134px;margin-top: 7px;margin-bottom: 0px;}
.p24{text-align: left;padding-left: 34px;padding-right: 134px;margin-top: 2px;margin-bottom: 0px;}
.p25{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 7px;margin-bottom: 0px;}
.p26{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 9px;margin-bottom: 0px;}
.p27{text-align: left;padding-left: 34px;margin-top: 19px;margin-bottom: 0px;}
.p28{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 2px;margin-bottom: 0px;}
.p29{text-align: justify;padding-left: 9px;padding-right: 96px;margin-top: 13px;margin-bottom: 0px;text-indent: -9px;}
.p30{text-align: justify;padding-right: 134px;margin-top: 0px;margin-bottom: 0px;}
.p31{text-align: left;margin-top: 43px;margin-bottom: 0px;}
.p32{text-align: justify;padding-right: 134px;margin-top: 10px;margin-bottom: 0px;}
.p33{text-align: justify;padding-right: 134px;margin-top: 13px;margin-bottom: 0px;}
.p34{text-align: justify;padding-right: 134px;margin-top: 12px;margin-bottom: 0px;}
.p35{text-align: left;padding-left: 34px;margin-top: 17px;margin-bottom: 0px;}
.p36{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 5px;margin-bottom: 0px;}
.p37{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 18px;margin-bottom: 0px;}
.p38{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 14px;margin-bottom: 0px;}
.p39{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 24px;margin-bottom: 0px;}
.p40{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 11px;margin-bottom: 0px;}
.p41{text-align: justify;padding-left: 9px;padding-right: 96px;margin-top: 3px;margin-bottom: 0px;text-indent: -9px;}
.p42{text-align: justify;padding-left: 9px;padding-right: 96px;margin-top: 5px;margin-bottom: 0px;}
.p43{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 0px;margin-bottom: 0px;}
.p44{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 15px;margin-bottom: 0px;}
.p45{text-align: left;padding-left: 34px;margin-top: 41px;margin-bottom: 0px;}
.p46{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 17px;margin-bottom: 0px;}
.p47{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 13px;margin-bottom: 0px;}
.p48{text-align: left;padding-left: 9px;padding-right: 96px;margin-top: 21px;margin-bottom: 0px;text-indent: -9px;}
.p49{text-align: left;margin-top: 7px;margin-bottom: 0px;}
.p50{text-align: left;padding-right: 134px;margin-top: 0px;margin-bottom: 0px;}
.p51{text-align: left;margin-top: 44px;margin-bottom: 0px;}
.p52{text-align: left;margin-top: 14px;margin-bottom: 0px;}
.p53{text-align: left;padding-left: 25px;margin-top: 12px;margin-bottom: 0px;}
.p54{text-align: left;padding-left: 25px;padding-right: 444px;margin-top: 5px;margin-bottom: 0px;}
.p55{text-align: left;padding-left: 25px;margin-top: 9px;margin-bottom: 0px;}
.p56{text-align: left;padding-left: 25px;padding-right: 506px;margin-top: 5px;margin-bottom: 0px;}
.p57{text-align: left;padding-left: 25px;margin-top: 2px;margin-bottom: 0px;}
.p58{text-align: left;padding-left: 25px;margin-top: 0px;margin-bottom: 0px;}
.p59{text-align: left;padding-left: 25px;padding-right: 406px;margin-top: 5px;margin-bottom: 0px;}
.p60{text-align: left;padding-left: 25px;margin-top: 10px;margin-bottom: 0px;}
.p61{text-align: left;padding-left: 25px;margin-top: 13px;margin-bottom: 0px;}
.p62{text-align: left;padding-left: 25px;padding-right: 381px;margin-top: 0px;margin-bottom: 0px;}
.p63{text-align: left;padding-left: 31px;margin-top: 0px;margin-bottom: 0px;}
.p64{text-align: left;padding-left: 65px;margin-top: 0px;margin-bottom: 0px;}
.p65{text-align: left;padding-left: 59px;padding-right: 437px;margin-top: 5px;margin-bottom: 0px;}
.p66{text-align: left;padding-left: 84px;margin-top: 0px;margin-bottom: 0px;}
.p67{text-align: left;padding-left: 84px;padding-right: 381px;margin-top: 7px;margin-bottom: 0px;}
.p68{text-align: left;padding-left: 84px;padding-right: 368px;margin-top: 17px;margin-bottom: 0px;}
.p69{text-align: left;padding-left: 84px;margin-top: 9px;margin-bottom: 0px;}
.p70{text-align: left;padding-left: 109px;padding-right: 500px;margin-top: 5px;margin-bottom: 0px;text-indent: -24px;}
.p71{text-align: left;padding-left: 84px;margin-top: 2px;margin-bottom: 0px;}
.p72{text-align: left;padding-left: 109px;padding-right: 262px;margin-top: 5px;margin-bottom: 0px;text-indent: -24px;}
.p73{text-align: left;padding-left: 59px;margin-top: 0px;margin-bottom: 0px;}
.p74{text-align: left;padding-left: 59px;margin-top: 7px;margin-bottom: 0px;}
.p75{text-align: left;padding-left: 59px;padding-right: 375px;margin-top: 5px;margin-bottom: 0px;}
.p76{text-align: left;padding-left: 59px;margin-top: 10px;margin-bottom: 0px;}
.p77{text-align: left;padding-left: 59px;padding-right: 331px;margin-top: 0px;margin-bottom: 0px;}
.p78{text-align: left;padding-left: 59px;margin-top: 12px;margin-bottom: 0px;}
.p79{text-align: left;padding-left: 59px;padding-right: 381px;margin-top: 0px;margin-bottom: 0px;}
.p80{text-align: left;padding-left: 34px;margin-top: 36px;margin-bottom: 0px;}
.p81{text-align: left;margin-top: 21px;margin-bottom: 0px;}
.p82{text-align: left;margin-top: 9px;margin-bottom: 0px;}
.p83{text-align: left;margin-top: 28px;margin-bottom: 0px;}
.p84{text-align: left;margin-top: 5px;margin-bottom: 0px;}
.p85{text-align: justify;padding-right: 134px;margin-top: 16px;margin-bottom: 0px;}
.p86{text-align: justify;padding-right: 134px;margin-top: 17px;margin-bottom: 0px;}
.p87{text-align: justify;padding-right: 134px;margin-top: 15px;margin-bottom: 0px;}
.p88{text-align: left;margin-top: 33px;margin-bottom: 0px;}
.p89{text-align: justify;padding-right: 134px;margin-top: 5px;margin-bottom: 0px;}
.p90{text-align: left;padding-left: 50px;padding-right: 343px;margin-top: 29px;margin-bottom: 0px;}
.p91{text-align: justify;padding-right: 134px;margin-top: 34px;margin-bottom: 0px;}
.p92{text-align: left;padding-left: 50px;padding-right: 576px;margin-top: 5px;margin-bottom: 0px;}
.p93{text-align: left;padding-left: 50px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p94{text-align: left;padding-left: 12px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p95{text-align: left;padding-left: 4px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p96{text-align: right;padding-right: 6px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p97{text-align: right;padding-right: 3px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p98{text-align: justify;padding-right: 134px;margin-top: 37px;margin-bottom: 0px;}
.p99{text-align: left;padding-left: 38px;margin-top: 0px;margin-bottom: 0px;}
.p100{text-align: justify;padding-left: 38px;padding-right: 134px;margin-top: 9px;margin-bottom: 0px;}
.p101{text-align: justify;padding-left: 38px;padding-right: 134px;margin-top: 16px;margin-bottom: 0px;}
.p102{text-align: left;padding-left: 82px;margin-top: 34px;margin-bottom: 0px;}
.p103{text-align: left;padding-left: 38px;margin-top: 24px;margin-bottom: 0px;}
.p104{text-align: justify;padding-left: 63px;padding-right: 212px;margin-top: 29px;margin-bottom: 0px;}
.p105{text-align: left;padding-left: 38px;margin-top: 43px;margin-bottom: 0px;}
.p106{text-align: justify;padding-left: 88px;padding-right: 613px;margin-top: 0px;margin-bottom: 0px;}
.p107{text-align: left;padding-left: 88px;padding-right: 475px;margin-top: 8px;margin-bottom: 0px;}
.p108{text-align: left;padding-left: 88px;padding-right: 563px;margin-top: 7px;margin-bottom: 0px;}
.p109{text-align: left;padding-left: 88px;margin-top: 17px;margin-bottom: 0px;}
.p110{text-align: justify;padding-left: 38px;padding-right: 134px;margin-top: 24px;margin-bottom: 0px;}
.p111{text-align: justify;padding-left: 38px;padding-right: 134px;margin-top: 12px;margin-bottom: 0px;}
.p112{text-align: left;padding-left: 4px;margin-top: 11px;margin-bottom: 0px;}
.p113{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 16px;margin-bottom: 0px;}
.p114{text-align: left;padding-left: 34px;margin-top: 21px;margin-bottom: 0px;}
.p115{text-align: left;padding-left: 34px;margin-top: 27px;margin-bottom: 0px;}
.p116{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 4px;margin-bottom: 0px;}
.p117{text-align: left;padding-left: 34px;margin-top: 10px;margin-bottom: 0px;}
.p118{text-align: left;padding-left: 34px;margin-top: 23px;margin-bottom: 0px;}
.p119{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 10px;margin-bottom: 0px;}
.p120{text-align: left;padding-left: 9px;padding-right: 96px;margin-top: 5px;margin-bottom: 0px;text-indent: -9px;}
.p121{text-align: justify;padding-left: 34px;padding-right: 134px;margin-top: 19px;margin-bottom: 0px;}
.p122{text-align: left;padding-left: 65px;padding-right: 237px;margin-top: 17px;margin-bottom: 0px;text-indent: -24px;}
.p123{text-align: left;padding-left: 65px;padding-right: 237px;margin-top: 22px;margin-bottom: 0px;text-indent: -24px;}
.p124{text-align: left;padding-left: 34px;margin-top: 2px;margin-bottom: 0px;}
.p125{text-align: left;padding-left: 40px;margin-top: 31px;margin-bottom: 0px;}
.p126{text-align: left;padding-left: 9px;padding-right: 96px;margin-top: 4px;margin-bottom: 0px;text-indent: -9px;}
.p127{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 0px;margin-bottom: 0px;}
.p128{text-align: left;padding-left: 39px;margin-top: 2px;margin-bottom: 0px;}
.p129{text-align: left;padding-left: 39px;margin-top: 0px;margin-bottom: 0px;}
.p130{text-align: left;padding-left: 39px;margin-top: 24px;margin-bottom: 0px;}
.p131{text-align: left;padding-left: 3px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p132{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 27px;margin-bottom: 0px;}
.p133{text-align: left;margin-top: 175px;margin-bottom: 0px;}
.p134{text-align: justify;padding-right: 134px;margin-top: 8px;margin-bottom: 0px;}
.p135{text-align: justify;padding-right: 134px;margin-top: 21px;margin-bottom: 0px;}
.p136{text-align: left;margin-top: 13px;margin-bottom: 0px;}
.p137{text-align: left;padding-left: 50px;padding-right: 444px;margin-top: 29px;margin-bottom: 0px;text-indent: -49px;}
.p138{text-align: left;margin-top: 16px;margin-bottom: 0px;}
.p139{text-align: left;padding-left: 50px;margin-top: 0px;margin-bottom: 0px;}
.p140{text-align: left;padding-left: 50px;padding-right: 381px;margin-top: 5px;margin-bottom: 0px;}
.p141{text-align: left;padding-left: 100px;padding-right: 500px;margin-top: 14px;margin-bottom: 0px;text-indent: -49px;}
.p142{text-align: left;padding-left: 100px;margin-top: 2px;margin-bottom: 0px;}
.p143{text-align: left;padding-left: 100px;margin-top: 13px;margin-bottom: 0px;}
.p144{text-align: left;padding-left: 100px;padding-right: 350px;margin-top: 5px;margin-bottom: 0px;}
.p145{text-align: left;padding-left: 100px;margin-top: 17px;margin-bottom: 0px;}
.p146{text-align: left;padding-left: 100px;padding-right: 318px;margin-top: 5px;margin-bottom: 0px;}
.p147{text-align: left;padding-left: 100px;margin-top: 16px;margin-bottom: 0px;}
.p148{text-align: left;padding-left: 100px;margin-top: 0px;margin-bottom: 0px;}
.p149{text-align: left;padding-left: 100px;margin-top: 12px;margin-bottom: 0px;}
.p150{text-align: left;padding-left: 100px;padding-right: 318px;margin-top: 0px;margin-bottom: 0px;}
.p151{text-align: left;padding-left: 100px;padding-right: 400px;margin-top: 0px;margin-bottom: 0px;}
.p152{text-align: left;padding-left: 100px;margin-top: 10px;margin-bottom: 0px;}
.p153{text-align: left;padding-left: 100px;padding-right: 237px;margin-top: 12px;margin-bottom: 0px;}
.p154{text-align: left;padding-left: 150px;margin-top: 0px;margin-bottom: 0px;}
.p155{text-align: left;padding-left: 100px;padding-right: 431px;margin-top: 12px;margin-bottom: 0px;}
.p156{text-align: left;padding-left: 100px;padding-right: 331px;margin-top: 12px;margin-bottom: 0px;}
.p157{text-align: left;padding-left: 100px;margin-top: 9px;margin-bottom: 0px;}
.p158{text-align: left;padding-left: 50px;margin-top: 12px;margin-bottom: 0px;}
.p159{text-align: justify;padding-right: 134px;margin-top: 29px;margin-bottom: 0px;}
.p160{text-align: left;padding-left: 6px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p161{text-align: left;padding-left: 38px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p162{text-align: left;margin-top: 39px;margin-bottom: 0px;}
.p163{text-align: left;padding-right: 134px;margin-top: 25px;margin-bottom: 0px;}
.p164{text-align: center;padding-right: 6px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p165{text-align: left;padding-left: 6px;margin-top: 0px;margin-bottom: 0px;}
.p166{text-align: left;padding-left: 6px;padding-right: 494px;margin-top: 5px;margin-bottom: 0px;text-indent: -5px;}
.p167{text-align: left;padding-left: 6px;margin-top: 2px;margin-bottom: 0px;}
.p168{text-align: left;padding-left: 6px;padding-right: 519px;margin-top: 0px;margin-bottom: 0px;text-indent: -5px;}
.p169{text-align: left;padding-left: 6px;margin-top: 1px;margin-bottom: 0px;}
.p170{text-align: left;padding-left: 6px;margin-top: 3px;margin-bottom: 0px;}
.p171{text-align: left;padding-left: 6px;padding-right: 500px;margin-top: 5px;margin-bottom: 0px;text-indent: -5px;}
.p172{text-align: left;margin-top: 2px;margin-bottom: 0px;}
.p173{text-align: justify;padding-right: 134px;margin-top: 31px;margin-bottom: 0px;}
.p174{text-align: left;margin-top: 25px;margin-bottom: 0px;}
.p175{text-align: left;margin-top: 17px;margin-bottom: 0px;}
.p176{text-align: justify;padding-right: 134px;margin-top: 6px;margin-bottom: 0px;}
.p177{text-align: left;padding-left: 31px;padding-right: 237px;margin-top: 30px;margin-bottom: 0px;text-indent: -24px;}
.p178{text-align: left;padding-left: 31px;padding-right: 237px;margin-top: 5px;margin-bottom: 0px;text-indent: -24px;}
.p179{text-align: left;margin-top: 26px;margin-bottom: 0px;}
.p180{text-align: justify;padding-right: 134px;margin-top: 11px;margin-bottom: 0px;}
.p181{text-align: left;padding-left: 12px;margin-top: 0px;margin-bottom: 0px;}
.p182{text-align: left;padding-right: 375px;margin-top: 5px;margin-bottom: 0px;text-indent: 13px;}
.p183{text-align: left;padding-left: 12px;margin-top: 2px;margin-bottom: 0px;}
.p184{text-align: left;padding-left: 12px;margin-top: 3px;margin-bottom: 0px;}
.p185{text-align: left;padding-left: 12px;padding-right: 375px;margin-top: 0px;margin-bottom: 0px;text-indent: -12px;}
.p186{text-align: left;padding-left: 12px;padding-right: 375px;margin-top: 1px;margin-bottom: 0px;text-indent: -12px;}
.p187{text-align: left;margin-top: 1px;margin-bottom: 0px;}
.p188{text-align: left;padding-left: 37px;margin-top: 0px;margin-bottom: 0px;}
.p189{text-align: justify;padding-left: 25px;padding-right: 134px;margin-top: 57px;margin-bottom: 0px;}
.p190{text-align: justify;padding-left: 25px;padding-right: 134px;margin-top: 26px;margin-bottom: 0px;}
.p191{text-align: left;padding-left: 25px;padding-right: 312px;margin-top: 70px;margin-bottom: 0px;}
.p192{text-align: left;padding-left: 56px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p193{text-align: justify;padding-left: 25px;padding-right: 134px;margin-top: 55px;margin-bottom: 0px;}
.p194{text-align: justify;padding-left: 25px;padding-right: 134px;margin-top: 23px;margin-bottom: 0px;}
.p195{text-align: left;margin-top: 45px;margin-bottom: 0px;}
.p196{text-align: justify;padding-right: 134px;margin-top: 4px;margin-bottom: 0px;}
.p197{text-align: left;margin-top: 27px;margin-bottom: 0px;}
.p198{text-align: left;padding-right: 134px;margin-top: 4px;margin-bottom: 0px;}
.p199{text-align: left;margin-top: 24px;margin-bottom: 0px;}
.p200{text-align: left;padding-left: 51px;padding-right: 318px;margin-top: 0px;margin-bottom: 0px;text-indent: -12px;}
.p201{text-align: left;padding-left: 51px;padding-right: 318px;margin-top: 1px;margin-bottom: 0px;text-indent: -12px;}
.p202{text-align: left;padding-left: 39px;margin-top: 1px;margin-bottom: 0px;}
.p203{text-align: left;padding-left: 51px;margin-top: 0px;margin-bottom: 0px;}
.p204{text-align: left;padding-left: 51px;padding-right: 368px;margin-top: 0px;margin-bottom: 0px;text-indent: -12px;}
.p205{text-align: left;padding-left: 51px;padding-right: 368px;margin-top: 1px;margin-bottom: 0px;text-indent: -12px;}
.p206{text-align: left;padding-left: 51px;padding-right: 337px;margin-top: 0px;margin-bottom: 0px;text-indent: -12px;}
.p207{text-align: left;padding-left: 51px;padding-right: 337px;margin-top: 1px;margin-bottom: 0px;text-indent: -12px;}
.p208{text-align: left;padding-left: 39px;padding-right: 375px;margin-top: 5px;margin-bottom: 0px;text-indent: 13px;}
.p209{text-align: left;padding-left: 51px;margin-top: 2px;margin-bottom: 0px;}
.p210{text-align: left;padding-left: 39px;margin-top: 18px;margin-bottom: 0px;}
.p211{text-align: left;padding-left: 39px;padding-right: 134px;margin-top: 0px;margin-bottom: 0px;}
.p212{text-align: left;padding-left: 39px;padding-right: 134px;margin-top: 6px;margin-bottom: 0px;}
.p213{text-align: left;padding-left: 39px;margin-top: 27px;margin-bottom: 0px;}
.p214{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 5px;margin-bottom: 0px;}
.p215{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 20px;margin-bottom: 0px;}
.p216{text-align: left;padding-left: 14px;padding-right: 96px;margin-top: 5px;margin-bottom: 0px;text-indent: -14px;}
.p217{text-align: left;padding-left: 107px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p218{text-align: left;padding-left: 220px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p219{text-align: left;padding-left: 213px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p220{text-align: left;padding-left: 44px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p221{text-align: justify;padding-right: 134px;margin-top: 19px;margin-bottom: 0px;}
.p222{text-align: left;margin-top: 20px;margin-bottom: 0px;}
.p223{text-align: justify;padding-right: 134px;margin-top: 24px;margin-bottom: 0px;}
.p224{text-align: justify;padding-right: 134px;margin-top: 7px;margin-bottom: 0px;}
.p225{text-align: justify;margin-top: 0px;margin-bottom: 0px;}
.p226{text-align: justify;margin-top: 533px;margin-bottom: 0px;}
.p227{text-align: left;padding-left: 31px;padding-right: 237px;margin-top: 22px;margin-bottom: 0px;text-indent: -24px;}
.p228{text-align: left;padding-left: 31px;padding-right: 243px;margin-top: 22px;margin-bottom: 0px;text-indent: -24px;}
.p229{text-align: left;padding-left: 31px;margin-top: 2px;margin-bottom: 0px;}
.p230{text-align: left;padding-left: 31px;padding-right: 243px;margin-top: 17px;margin-bottom: 0px;text-indent: -24px;}
.p231{text-align: left;padding-left: 75px;margin-top: 0px;margin-bottom: 0px;}
.p232{text-align: justify;padding-right: 134px;margin-top: 1px;margin-bottom: 0px;}
.p233{text-align: left;margin-top: 22px;margin-bottom: 0px;}
.p234{text-align: justify;padding-left: 50px;padding-right: 613px;margin-top: 0px;margin-bottom: 0px;}
.p235{text-align: justify;padding-left: 50px;padding-right: 557px;margin-top: 18px;margin-bottom: 0px;}
.p236{text-align: left;padding-left: 32px;margin-top: 0px;margin-bottom: 0px;white-space: nowrap;}
.p237{text-align: left;padding-left: 50px;padding-right: 582px;margin-top: 10px;margin-bottom: 0px;}
.p238{text-align: justify;padding-left: 50px;padding-right: 582px;margin-top: 0px;margin-bottom: 0px;}
.p239{text-align: left;padding-left: 50px;padding-right: 400px;margin-top: 15px;margin-bottom: 0px;}
.p240{text-align: left;padding-left: 6px;margin-top: 12px;margin-bottom: 0px;}
.p241{text-align: left;padding-left: 31px;padding-right: 168px;margin-top: 17px;margin-bottom: 0px;text-indent: -24px;}
.p242{text-align: left;padding-left: 31px;padding-right: 168px;margin-top: 22px;margin-bottom: 0px;text-indent: -24px;}
.p243{text-align: left;padding-left: 31px;padding-right: 168px;margin-top: 21px;margin-bottom: 0px;text-indent: -24px;}
.p244{text-align: left;padding-left: 6px;margin-top: 17px;margin-bottom: 0px;}
.p245{text-align: left;padding-left: 39px;margin-top: 21px;margin-bottom: 0px;}
.p246{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 1px;margin-bottom: 0px;}
.p247{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 16px;margin-bottom: 0px;}
.p248{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 23px;margin-bottom: 0px;}
.p249{text-align: left;padding-left: 39px;margin-top: 19px;margin-bottom: 0px;}
.p250{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 9px;margin-bottom: 0px;}
.p251{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 12px;margin-bottom: 0px;}
.p252{text-align: justify;padding-left: 39px;padding-right: 134px;margin-top: 17px;margin-bottom: 0px;}
.p253{text-align: left;padding-left: 39px;margin-top: 12px;margin-bottom: 0px;}
.p254{text-align: left;margin-top: 6px;margin-bottom: 0px;}
.p255{text-align: justify;padding-right: 134px;margin-top: 23px;margin-bottom: 0px;}
.p256{text-align: left;margin-top: 30px;margin-bottom: 0px;}
.p257{text-align: left;padding-left: 6px;margin-top: 14px;margin-bottom: 0px;}
.p258{text-align: left;padding-left: 22px;padding-right: 134px;margin-top: 5px;margin-bottom: 0px;text-indent: -16px;}
.p259{text-align: left;padding-left: 22px;padding-right: 134px;margin-top: 0px;margin-bottom: 0px;text-indent: -16px;}
.p260{text-align: left;padding-left: 22px;padding-right: 134px;margin-top: 5px;margin-bottom: 0px;text-indent: -22px;}

.td0{padding: 0px;margin: 0px;width: 12px;vertical-align: bottom;}
.td1{padding: 0px;margin: 0px;width: 516px;vertical-align: bottom;}
.td2{padding: 0px;margin: 0px;width: 20px;vertical-align: bottom;}
.td3{padding: 0px;margin: 0px;width: 31px;vertical-align: bottom;}
.td4{padding: 0px;margin: 0px;width: 485px;vertical-align: bottom;}
.td5{padding: 0px;margin: 0px;width: 175px;vertical-align: bottom;}
.td6{padding: 0px;margin: 0px;width: 26px;vertical-align: bottom;}
.td7{padding: 0px;margin: 0px;width: 44px;vertical-align: bottom;}
.td8{padding: 0px;margin: 0px;width: 56px;vertical-align: bottom;}
.td9{padding: 0px;margin: 0px;width: 119px;vertical-align: bottom;}
.td10{padding: 0px;margin: 0px;width: 70px;vertical-align: bottom;}
.td11{padding: 0px;margin: 0px;width: 66px;vertical-align: bottom;}
.td12{padding: 0px;margin: 0px;width: 53px;vertical-align: bottom;}
.td13{padding: 0px;margin: 0px;width: 19px;vertical-align: bottom;}
.td14{padding: 0px;margin: 0px;width: 47px;vertical-align: bottom;}
.td15{padding: 0px;margin: 0px;width: 22px;vertical-align: bottom;}
.td16{padding: 0px;margin: 0px;width: 51px;vertical-align: bottom;}
.td17{padding: 0px;margin: 0px;width: 75px;vertical-align: bottom;}
.td18{padding: 0px;margin: 0px;width: 138px;vertical-align: bottom;}
.td19{padding: 0px;margin: 0px;width: 251px;vertical-align: bottom;}
.td20{padding: 0px;margin: 0px;width: 103px;vertical-align: bottom;}
.td21{padding: 0px;margin: 0px;width: 194px;vertical-align: bottom;}
.td22{padding: 0px;margin: 0px;width: 241px;vertical-align: bottom;}
.td23{padding: 0px;margin: 0px;width: 73px;vertical-align: bottom;}
.td24{padding: 0px;margin: 0px;width: 126px;vertical-align: bottom;}
.td25{padding: 0px;margin: 0px;width: 122px;vertical-align: bottom;}
.td26{padding: 0px;margin: 0px;width: 357px;vertical-align: bottom;}
.td27{padding: 0px;margin: 0px;width: 101px;vertical-align: bottom;}
.td28{padding: 0px;margin: 0px;width: 125px;vertical-align: bottom;}
.td29{padding: 0px;margin: 0px;width: 458px;vertical-align: bottom;}
.td30{padding: 0px;margin: 0px;width: 226px;vertical-align: bottom;}
.td31{padding: 0px;margin: 0px;width: 201px;vertical-align: bottom;}
.td32{padding: 0px;margin: 0px;width: 235px;vertical-align: bottom;}
.td33{padding: 0px;margin: 0px;width: 128px;vertical-align: bottom;}
.td34{padding: 0px;margin: 0px;width: 147px;vertical-align: bottom;}
.td35{padding: 0px;margin: 0px;width: 320px;vertical-align: bottom;}
.td36{padding: 0px;margin: 0px;width: 57px;vertical-align: bottom;}
.td37{padding: 0px;margin: 0px;width: 69px;vertical-align: bottom;}
.td38{padding: 0px;margin: 0px;width: 132px;vertical-align: bottom;}
.td39{padding: 0px;margin: 0px;width: 100px;vertical-align: bottom;}
.td40{padding: 0px;margin: 0px;width: 88px;vertical-align: bottom;}
.td41{padding: 0px;margin: 0px;width: 188px;vertical-align: bottom;}
.td42{padding: 0px;margin: 0px;width: 151px;vertical-align: bottom;}
.td43{padding: 0px;margin: 0px;width: 87px;vertical-align: bottom;}
.td44{padding: 0px;margin: 0px;width: 25px;vertical-align: bottom;}
.td45{padding: 0px;margin: 0px;width: 471px;vertical-align: bottom;}
.td46{padding: 0px;margin: 0px;width: 16px;vertical-align: bottom;}
.td47{padding: 0px;margin: 0px;width: 150px;vertical-align: bottom;}
.td48{padding: 0px;margin: 0px;width: 60px;vertical-align: bottom;}
.td49{padding: 0px;margin: 0px;width: 210px;vertical-align: bottom;}
.td50{padding: 0px;margin: 0px;width: 50px;vertical-align: bottom;}
.td51{padding: 0px;margin: 0px;width: 170px;vertical-align: bottom;}
.td52{padding: 0px;margin: 0px;width: 41px;vertical-align: bottom;}
.td53{padding: 0px;margin: 0px;width: 129px;vertical-align: bottom;}
.td54{padding: 0px;margin: 0px;width: 62px;vertical-align: bottom;}

.tr0{height: 17px;}
.tr1{height: 25px;}
.tr2{height: 26px;}
.tr3{height: 15px;}
.tr4{height: 14px;}
.tr5{height: 29px;}

.t0{width: 548px;margin-top: 59px;font: 12px 'Gabriola';}
.t1{width: 245px;margin-left: 34px;margin-top: 17px;font: 12px 'Gabriola';}
.t2{width: 408px;margin-top: 24px;font: 12px 'Gabriola';}
.t3{width: 583px;margin-left: 34px;font: 12px 'Gabriola';}
.t4{width: 583px;margin-left: 39px;font: 12px 'Gabriola';}
.t5{width: 452px;margin-top: 26px;font: 12px 'Gabriola';}
.t6{width: 188px;margin-top: 26px;font: 12px 'Gabriola';}
.t7{width: 238px;margin-left: 75px;margin-top: 12px;font: 12px 'Gabriola';}
.t8{width: 496px;font: 12px 'Gabriola';}
.t9{width: 483px;margin-left: 6px;margin-top: 21px;font: 12px 'Gabriola';}
.t10{width: 289px;margin-left: 50px;margin-top: 9px;font: 12px 'Gabriola';}
.t11{width: 213px;margin-left: 50px;margin-top: 13px;font: 12px 'Gabriola';}

</STYLE>
</HEAD>

<BODY>
<DIV id="page_1">
<DIV id="p1dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p1img1"></DIV>


<DIV id="id1_1">
<P class="p0 ft0">Post Memory Corruption Memory Analysis</P>
<P class="p1 ft2">Jonathan Brossard - <NOBR>jonathan.brossard@toucan-system.com</NOBR></P>
<P class="p2 ft2">Security Research Engineer & CEO, Toucan System, France</P>
<P class="p3 ft2">Blackhat Briefings Conference, Las Vegas, 2011</P>
<P class="p4 ft0">"Normality is the route to nowhere."<SPAN class="ft1"> </SPAN><SPAN class="ft2">Ridderstrale and Nordstorm</SPAN></P>
<P class="p5 ft3">Abstract. In this article, we introduce a new exploitation methodology of invalid memory reads and writes, based on dataflow analysis after a memory corruption bug has occurred inside a running process.</P>
<P class="p6 ft4">We will expose a methodology which shall help writing a reliable exploit out of a PoC triggering an in- valid memory write, in presence of modern security defense mechanism such as compiler enhancements (such as SSP...), lib protections (eg: safe heap unlinking), linking and dynamic linking enhancements (full read only GOT and relocations) or kernel anti exploitation features (ASLR, NX...).</P>
<P class="p7 ft5">In particular, we will demonstrate how to : <SPAN class="ft1"></SPAN>nd all the function pointers inside a running process, how to determine which ones would have been dereferenced after the Segmentation fault if the process had kept executing, which ones are truncatable (in particular with 0x00000000). In 
ase all of the above fail, we will demonstrate how to test for overwrites in specific locations in order to indirectly trigger a second vulnerability allowing greater control and eventually full 
control <SPAN class="ft1"></SPAN>ow hijacking. All of the above without needing the source code of the application debugged.</P>
<P class="p6 ft5">In the case of invalid memory reads, we will show how to indirectly influence the control flow of execution by reading arbitrary values, how to trace all the unaligned memory access and how to test if an invalid read an be turned into an invalid write or at least used to infer the mapping of the binary.</P>
<P class="p8 ft4">We will also introduce a new debugging technique which allows for very exaustive dynamic testing of all of the above by forcing the debugged process to fork(). All those steps are realized automatically and provide a rating of the best read/write location based on probabilities of mapping addresses (in the hope to defeat ASLR).</P>
<P class="p7 ft5">These techniques were implemented in the form of a proof of concept tool running under GNU/Linux and Intel architectures : pmcma<A href="#page_1"><SPAN class="ft6">1</SPAN></A>.</P>
<P class="p9 ft5"><SPAN class="ft7">Keywords:</SPAN> Exploit automation, post memory corruption analysis, debugging, memory protections, in- valid memory writes.</P>
</DIV>
<DIV id="id1_2">
<P class="p10 ft5"><SPAN class="ft8">1</SPAN><SPAN class="ft9">The official website of the tool is http://www.pmcma.org</P>
</DIV>
</DIV>
<DIV id="page_2">


<P class="p11 ft0">Table of Contents</P>
<TABLE cellpadding=0 cellspacing=0 class="t0">
<TR>
	<TD class="tr0 td0"><P class="p12 ft10"><A href="#page_3">1</A></P></TD>
	<TD colspan=2 class="tr0 td1"><P class="p13 ft10"><A href="#page_3">Introdu
tion </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr0 td2"><P class="p14 ft10">3</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft10"><A href="#page_4">2</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft10"><A href="#page_4">Related work </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">4</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft10"><A href="#page_5">3</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft10"><A href="#page_5">mk_fork() : writing "weird debuggers" for "weird programs" </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">5</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_5">3.1</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_5">Motivation </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">5</P></TD>
</TR>
<TR>
	<TD class="tr2 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr2 td3"><P class="p13 ft10"><A href="#page_6">3.2</A></P></TD>
	<TD class="tr2 td4"><P class="p15 ft10"><A href="#page_6">Methodology </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr2 td2"><P class="p14 ft10">6</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_7">3.3</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_7">mk_fork() implementation </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">7</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_9">3.4</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_9">Limitations </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">9</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft10"><A href="#page_9">4</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft10"><A href="#page_9">Here be dragons : zombie reaping </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">9</P></TD>
</TR>
<TR>
	<TD class="tr2 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr2 td3"><P class="p13 ft10"><A href="#page_9">4.1</A></P></TD>
	<TD class="tr2 td4"><P class="p15 ft10"><A href="#page_9">Dealing with SIGCHLD </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr2 td2"><P class="p14 ft10">9</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_11">4.2</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_11">Pro
esses grouping </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">11</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft10"><A href="#page_12">5</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft10"><A href="#page_12">Exploiting invalid memory writes </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">12</P></TD>
</TR>
<TR>
	<TD class="tr2 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr2 td3"><P class="p13 ft10"><A href="#page_12">5.1</A></P></TD>
	<TD class="tr2 td4"><P class="p15 ft10"><A href="#page_12">Finding all the fun
tion pointers dereferen
ed after an invalid write </A>. . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr2 td2"><P class="p14 ft10">12</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_12">5.2</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_12">Over</A><A href="#page_12"><SPAN class="ft1"></SPAN></A><A href="#page_12">ows </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">12</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_12">5.3</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_12">Partial overwrites and pointers trun
ations </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">12</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_15">5.4</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_15">Dis
overing unaligned memory reads </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">15</P></TD>
</TR>
<TR>
	<TD class="tr2 td0"><P class="p12 ft10"><A href="#page_18">6</A></P></TD>
	<TD colspan=2 class="tr2 td1"><P class="p13 ft10"><A href="#page_18">ASLR and its limits </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr2 td2"><P class="p14 ft10">18</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_18">6.1</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_18">E</A><A href="#page_18"><SPAN class="ft1"></SPAN></A><A href="#page_18">e
tive testing of ASLR </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">18</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_21">6.2</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_21">Non Position Independant Exe
utables </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">21</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_21">6.3</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_21">Prelinking </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">21</P></TD>
</TR>
<TR>
	<TD class="tr2 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr2 td3"><P class="p13 ft10"><A href="#page_21">6.4</A></P></TD>
	<TD class="tr2 td4"><P class="p15 ft10"><A href="#page_21">Biased ASLR </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr2 td2"><P class="p14 ft10">21</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_22">6.5</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_22">Memory mapping leakage </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">22</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft10"><A href="#page_26">7</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft10"><A href="#page_26">Extending the 
apabilities of pm
ma </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">26</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_26">7.1</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_26">Call tables and returns to registers+o</A><A href="#page_26"><SPAN class="ft1"></SPAN></A><A href="#page_26">sets </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">26</P></TD>
</TR>
<TR>
	<TD class="tr2 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr2 td3"><P class="p13 ft10"><A href="#page_26">7.2</A></P></TD>
	<TD class="tr2 td4"><P class="p15 ft10"><A href="#page_26">Sear
hing for pointers to stru
tures (
ontaining fun
tion pointers) </A>. . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr2 td2"><P class="p14 ft10">26</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_28">7.3</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_28">Testing exhaustively arbitrary writes </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">28</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr1 td3"><P class="p13 ft10"><A href="#page_29">7.4</A></P></TD>
	<TD class="tr1 td4"><P class="p15 ft10"><A href="#page_29">Testing invalid reads </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">29</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft10"><A href="#page_29">8</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft10"><A href="#page_29">Sta
k desyn
hronization </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">29</P></TD>
</TR>
<TR>
	<TD class="tr2 td0"><P class="p12 ft10"><A href="#page_30">9</A></P></TD>
	<TD colspan=2 class="tr2 td1"><P class="p13 ft10"><A href="#page_30">Performan
e 
onsiderations </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr2 td2"><P class="p14 ft10">30</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft10"><A href="#page_30">10</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft10"><A href="#page_30">Con
lusion </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft10">30</P></TD>
</TR>
<TR>
	<TD class="tr1 td0"><P class="p12 ft2"><A href="#page_30">11</A></P></TD>
	<TD colspan=2 class="tr1 td1"><P class="p13 ft2"><A href="#page_30">a
knowledgements </A>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P></TD>
	<TD class="tr1 td2"><P class="p14 ft2">30</P></TD>
</TR>
</TABLE>
</DIV>
<DIV id="page_3">
<DIV id="p3dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p3img1"></DIV>


<DIV id="id3_1">
<P class="p16 ft2"><SPAN class="ft2">1</SPAN><SPAN class="ft12">Introdu
tion</SPAN></P>
<P class="p17 ft4">Determining exploitability is hard, and writing exploits is hard. In fa
t, due to theoreti
al limitations (id est: "Halting Problem"), those two problems are the two sides of the same 
oin. Proving unex- ploitability is infeasible in the general 
ase, and pra
ti
ally for the vast majority of 
omputer programs a
tually used nowadays.</P>
<P class="p18 ft5">In this paper, we will examine exploitability in a systemati
 way, fo
using on what happens in memory after a bug is triggered, rather than tra
ing or ba
ktra
king what has happened before. To the best of the author's knowledge, this is a new approa
h.</P>
<P class="p19 ft13">Our goal is to help exploit (semi)automation by building exploitation models based on 
onstraints gath- ered from the environment (in parti
ular, the presen
e of se
urity 
ountermeasures su
h as ALSR[1<SPAN class="ft1">℄ </SPAN>or <NOBR>non-exe
utable</NOBR> memory[2<SPAN class="ft1">℄ </SPAN>thanks to kernel[3<SPAN class="ft1">℄ </SPAN>or hardware[4<SPAN class="ft1">℄ </SPAN>enhan
ements, as well as 
ompiler enhan
ements su
h as Data Hardening[5<SPAN class="ft1">℄</SPAN>, FORTIFY SOURCE[6<SPAN class="ft1">℄ </SPAN>et
), and to allow for the pra
ti
al testing of those models in order to (in)validate them.</P>
<P class="p20 ft5">We will primarily fo
us on invalid memory write bugs be
ause of the spe
ial role they play in modern exploitation. Invalid memory dereferen
es in read mode used for the purposes of information leakage or indire
t memory exploitation will also be dis
ussed in this arti
le.</P>
<P class="p21 ft3">The main 
ontributions of this arti
le are:</P>
<P class="p22 ft5"><SPAN class="ft5">-</SPAN><SPAN class="ft9">A methodology to dis
over all the potential fun
tion pointers inside the address spa
e of a pro
ess at any given point in time.</SPAN></P>
<P class="p23 ft5"><SPAN class="ft5">-</SPAN><SPAN class="ft9">A methodology to dis
over all the fun
tion pointers a
tually dereferen
ed by a pro
ess from a given point in time, given a </SPAN><SPAN class="ft1"></SPAN>xed set of input data.</P>
<P class="p24 ft3"><SPAN class="ft3">-</SPAN><SPAN class="ft14">A methodology to </SPAN><SPAN class="ft1"></SPAN>nd all the fun
tion pointers exploitable by trun
ation in 
ase of an arbitrary write subje
t to 
onditions (su
h as not 
ontrolling the value being dereferen
ed).</P>
<P class="p22 ft5"><SPAN class="ft5">-</SPAN><SPAN class="ft15">A methodology to </SPAN><SPAN class="ft1"></SPAN>nd all the unaligned memory reads from a given point in time during the exe
ution of a pro
ess.</P>
<P class="p25 ft5"><SPAN class="ft5">-</SPAN><SPAN class="ft16">A new debugging te
hnique whi
h allows the validation of all of the above, as well as the testing of arbitrary data modi</SPAN><SPAN class="ft1"></SPAN>
ations inside the address spa
e of a pro
ess in order to a
hieve 
ontrol <SPAN class="ft1"></SPAN>ow hija
king from an arbitrary memory write.</P>
<P class="p26 ft4">All those te
hniques have been implemented in the form of a proof of 
on
ept tool for the GNU/Linux x86 Intel ar
hite
tures. They 
ould, without any loss of generality, be extended to any operating system or ar
hite
ture with the ex
eption of the last debugging te
hnique, whi
h requires the presen
e of the fork() system 
all and is therefore limited to *NIX operating systems<A href="#page_3"><SPAN class="ft6">2</SPAN></A>.</P>
<P class="p18 ft5">This parti
ular debugging te
hnique doesn't require the debugged pro
ess to be restarted using ex- e
ve(), and therefore preserves most of the mapping of the appli
ation (whi
h may be hard to <NOBR>re-
reate</NOBR> be
ause of the large entropy used in randomizing a pro
ess' address spa
e under modern OSes). This te
hnique is also believed to be the most e<SPAN class="ft1"></SPAN>e
tive to a
hieve this result (by 
onstru
tion) both in terms of speed and resour
es.</P>
<P class="p27 ft2">Finally, sin
e overwriting fun
tion pointers doesn't allow dire
t shell
ode exe
ution anymore be
ause of</P>
<P class="p28 ft13"><SPAN class="ft0">W ˆ</SPAN>X mappings, we introdu
e a new exploitation te
hnique whi
h works even under the most se
urity enhan
ed kernels su
h as grse
urity. We 
all it "sta
k desyn
hronization". It allows frame faking inside the sta
k itself by having a 
ontrolled fun
tion pointer return to a 
arefully 
hosen fun
tion prologue instead of returning to a shell
ode dire
tly.</P>
<P class="p16 ft2">It is worth noting that we do not seek full exploit generation in this whitepaper, the output of our tool</P>
<P class="p29 ft13"><SPAN class="ft8">2</SPAN><SPAN class="ft17">A
tually, Se
urity Resear
her Mark Dowd made us aware that it may be possible to simulate a fork() under Windows too... Implementation details would be non trivial though, sin
e the pro
ess 
reation me
hanism is entirely di</SPAN><SPAN class="ft1"></SPAN>erent.</P>
</DIV>
<DIV id="id3_2">
<P class="p10 ft0">3</P>
</DIV>
</DIV>
<DIV id="page_4">


<DIV id="id4_1">
<P class="p30 ft5">being a roadmap to exploitation rather than exe
utable (or sour
e) 
ode. This roadmap needs to be implemented using both 
ontrol <SPAN class="ft1"></SPAN>ow and data <SPAN class="ft1"></SPAN>ow analysis of the pro
ess prior to the bug, whi
h is fortunately what virtually any existing debugging tool is 
apable of a

omplishing.</P>
<P class="p31 ft0"><SPAN class="ft0">2</SPAN><SPAN class="ft18">Related work</SPAN></P>
<P class="p32 ft4">Be
ause of the theori
al limitations invoked previously, earlier resear
h on automati
 exploitation tend to fo
us on numeri
al rather than analyti
al solutions. It is indeed less intelle
tually satisfying (it 
an- not be proved that a solution will a
tually be found in general), but interresting results have been a
hieved nonetheless.</P>
<P class="p33 ft19">More pre
isely, they all share a 
ommon underlying methodology : starting from a given program input leading to a deterministi
 memory 
orruption, they express the 
onstraints on the input data in order to have it keep following the very same path (otherwise we're ba
k to the Halting Problem and in pra
ti
e to path exploration explosion), then turn ea
h instru
tion into a set of 
onstraints, express the desired result (id est: register set when re
eiving a Segmentation fault) in terms of the same 
onstraints. Then they solve the equation numeri
ally. Both taint analysis at assembly level (whether an intermediary language is used[7<SPAN class="ft1">℄ </SPAN>or not[8<SPAN class="ft1">℄</SPAN>) and SAT Solvers[9<SPAN class="ft1">℄</SPAN><A href="#page_31">[10</A><SPAN class="ft1">℄ </SPAN>used on 
onstraints expressed from C sour
e seem to give satisfying results in pra
ti
e, eventually modifying the input data to lead to the expe
ted set of registers when triggering the bug, thereby leading to exe
ution of arbitrary 
ode.</P>
<P class="p33 ft4">Unfortunately, in pra
ti
e the exploits 
reated using the aforementioned te
hniques often do not work under realisti
 modern operating systems, in parti
ular be
ause the "
omplete exploits" generated au- tomati
ally omit to take into a

ount the additional 
omplexity brought by se
urity prote
tions su
h as <NOBR>non-exe
utable</NOBR> memory pages or Address Spa
e Layer Randomization (ASLR).</P>
<P class="p33 ft20">If those te
hniques seem to give interesting results on simple vulnerabilities su
h as sta
k over<SPAN class="ft1"></SPAN>ows under basi
 
onditions (no sta
k 
anaries, no address spa
e layer randomization and all se
tions being exe
utable), they 
annot 
ope with more 
omplex vulnerabilities su
h as heap over<SPAN class="ft1"></SPAN>ows (overwriting heap <NOBR>meta-data</NOBR> typi
ally require having multiple memory lo
ations set to appropriate values in order to pass the various lib
 
he
ks before a
hieving a proper arbitrary write in memory) nor do they work with modern Operating Systems, whi
h have enhan
ed kernels and 
ompiler tool
hains to prevent triv- ial exploitation.</P>
<P class="p34 ft4">In reality, dealing with those se
urity prote
tions is in itself what most se
urity resear
hers and ha
kers alike a
tually spend their time on when writing exploits. It requires their exploitation methodologies to be <NOBR>environment-aware,</NOBR> those prote
tions being implemented at di<SPAN class="ft1"></SPAN>erent levels, ranging from 
ompiler tool
hains enhan
ements[6<SPAN class="ft1">℄ </SPAN>to kernel modi<SPAN class="ft1"></SPAN>
ations[11<SPAN class="ft1">℄</SPAN>.</P>
<P class="p33 ft4">In the rest of this arti
le, we will fo
us on what happens inside a pro
ess after it triggered a Seg- mentation Fault , assuming that the 
ontrol <SPAN class="ft1"></SPAN>ow and data <SPAN class="ft1"></SPAN>ow analysis of input data leading to this Segmentation Fault, whi
h are still the mandatory steps to determine exploitability, 
an be performed using 
ommonly available tools (gdb, valgrind, dmallo
, ele
tri
fen
e,...).</P>
</DIV>
<DIV id="id4_2">
<P class="p10 ft0">4</P>
</DIV>
</DIV>
<DIV id="page_5">
<DIV id="p5dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p5img1"></DIV>


<DIV id="id5_1">
<P class="p16 ft0"><SPAN class="ft0">3</SPAN><SPAN class="ft18">mk_fork() : writing "weird debuggers" for "weird programs"</SPAN></P>
<P class="p35 ft0"><SPAN class="ft0">3.1</SPAN><SPAN class="ft21">Motivation</SPAN></P>
<P class="p36 ft4">An arbitrary anything/anywhere write allows an atta
ker to overwrite arbitrary data in se
tions mapped with writable permissions. In order to a
hieve 
ontrol <SPAN class="ft1"></SPAN>ow modi<SPAN class="ft1"></SPAN>
ation to exe
ute arbitrary 
ode, the most straight forward te
hnique is to overwrite a fun
tion pointer that will later be dereferen
ed during the normal <SPAN class="ft1"></SPAN>ow of exe
ution.</P>
<P class="p37 ft5">Depending on the target binary, a few su
h pointers may be known without further reverse engineering. In fa
t, appli
ations linked against the GNU lib
 library 
ontain de fa
to su
h a pointer : the fun
tion pointer asso
iated with the .dtors se
tion. This pointer has long been used[12<SPAN class="ft1">℄ </SPAN>to exe
ute arbitrary 
ode instead of the legitimate glib
 destru
tors in 
ase of arbitrary write vulnerabilities, parti
ularly when exploiting missing format string vulnerabilities lo
ally.</P>
<P class="p18 ft5">This parti
ular te
hnique, while popular in the early 2000's, has several limitations. First of all, it assumes the appli
ation will exit 
leanly by 
alling exit(). If the atta
ker is unable to pursue normal exe
ution mu
h longer after triggering the vulnerability (fairly 
ommon in 
ase of heap over<SPAN class="ft1"></SPAN>ows, where heap metadata is irre
overably 
orrupted and will sooner or later for
e the appli
ation to quit by 
alling abort() instead of exit(), hen
e not 
alling the normal destru
tors), the aforementioned fun
tion pointer will not even be dereferen
ed.</P>
<P class="p38 ft5">Se
ondly, a
hieving arbitrary remote exe
ution when the appli
ation is exiting may be a bit late. If the atta
ker was to atta
k a remote servi
e whi
h typi
ally only 
alls exit() when the server shuts down (whi
h may literally take years), this atta
k ve
tor may not be interesting at all. A 
arefully 
oded setuid appli
ation may also 
hose to drop privileges before exiting, hen
e wasting the atta
k ve
tor for a lo
al atta
ker.</P>
<P class="p17 ft5">Thirdly, guessing the lo
ation of the .dtors se
tion, while easy if the binary wasn't 
ompiled as a PIE is not immediately given in the opposite 
ase, be
ause the data se
tion of the binary is then randomized. Finally, the appli
ation may not be linked with glib
 at all (use of ulib
 for instan
e), in whi
h 
ase, this fun
tion pointer is simply not available. In any 
ase, it is possible to modify the linking pro
ess through a s
ript[<SPAN class="ft0">?</SPAN><SPAN class="ft1">℄ </SPAN>to make the .dtors se
tion non writable, whi
h mitigates this atta
k ve
tor 
ompletely. This is a

eptable for the vast majority of appli
ations sin
e the use of 
ustom destru
tors is in fa
t not widespread.</P>
<P class="p39 ft20">The se
ond popular te
hnique is to overwrite a pointer in the Global O<SPAN class="ft1"></SPAN>set Table (GOT). When 
alling pro
edures whose 
ode is stored in separate obje
ts su
h as shared libraries, the lazy dynami
 linking <SPAN class="ft1"></SPAN>rst transfers 
ontrol to the Pro
ess Linkage Table (PLT), whi
h is a trampoline to the GOT. Over- writing the GOT entry to say, printf() would allow an atta
ker to modify the <SPAN class="ft1"></SPAN>ow of exe
ution to an arbitrary lo
ation when printf() would later be 
alled anywhere within the appli
ation. This te
hnique is also attra
tive sin
e binaries not 
ompiled as Position Independent Exe
utables (PIE) have their GOT stored at a <SPAN class="ft1"></SPAN>x lo
ation.</P>
<P class="p40 ft20">Unfortunately for the atta
ker, re
ent[5<SPAN class="ft1">℄ </SPAN>modi<SPAN class="ft1"></SPAN>
ations to the linker and dynami
 linker allow<SPAN class="ft6">3 </SPAN>for the relo
ations to be performed entirely during the loading pro
ess. Sin
e the GOT is then fully resolved, it 
an be set read only by a simple 
all to mprote
t(). The net result is that an atta
ker 
annot write to the GOT at all anymore, hen
e mitigating this atta
k ve
tor entirely. This early binding 
omes at a performan
e 
ost (lazy binding no longer applies, and even referen
es that would not have been used during a spe
i<SPAN class="ft1"></SPAN>
 run of the appli
ation are resolved anyways), and is therefore not applied sys- temati
ally to all binaries under all Linux distributions. That being said, it is absolutely possible to</P>
<P class="p41 ft2"><SPAN class="ft8">3</SPAN><SPAN class="ft22">When 
ompiling appli
ations using g

, and zith the following </SPAN><SPAN class="ft1"></SPAN>ags: <NOBR>"-Wl</NOBR> <NOBR>-z</NOBR> relro <NOBR>-z</NOBR> now". Using only <NOBR>"-Wl</NOBR> <NOBR>-z</NOBR> relro " allows for internal reorganization of the se
tions of the binary, putting the GOT before writable se
tions su
h as</P>
<P class="p42 ft5">.data and .bss. This prevents GOT overwriting in 
ase of user 
ontrolled bu<SPAN class="ft1"></SPAN>er over<SPAN class="ft1"></SPAN>ows in those writable se
tions. Adding the <NOBR>"-z</NOBR> now" option also for
es relo
ations to be performed at load time, and enfor
e a 
all to mprote
t() to render the GOT unwritable.</P>
</DIV>
<DIV id="id5_2">
<P class="p10 ft0">5</P>
</DIV>
</DIV>
<DIV id="page_6">
<DIV id="p6dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p6img1"></DIV>


<DIV id="id6_1">
<P class="p43 ft5">
reate a tool
hain that would enfor
e those linking options to all the binaries in the system, e<SPAN class="ft1"></SPAN>e
tively killing this atta
k ve
tor entirely. The Gentoo Hardened distribution is su
h an instan
e of a distri- bution that privileged se
urity over performan
e by enfor
ing this new feature by default on all binaries.</P>
<P class="p44 ft5">An other pointer prior resear
hers used in the past is the array of pointers 
alled by at_exit(). While it has been shown[13<SPAN class="ft1">℄ </SPAN>that overwriting a double word in this glib
 global data 
ould grant arbitrary 
ode exe
ution, appli
ations a
tually using at_exit() tend to be fairly rare. The virtue of this example is generalize the overwrite of fun
tion pointers not only in the mapping of the appli
ation itself, but also in the writable mappings of the libraries it is linked to. In a way, the present paper 
an be seen as an extreme generalization of this te
hnique.</P>
<P class="p44 ft5">If deferen
ing a fun
tion pointer is indeed a good idea, publi
ly available debuggers do a poor job at listing them. This is understandable sin
e what happens inside an appli
ation after a Segmentation Fault is of little interest to normal software developers, whose fo
us is to <SPAN class="ft1"></SPAN>x bugs, not to write exploits. We will therefore without further due introdu
e a te
hnique to automati
ally dete
t all the fun
tion pointers possibly dereferen
ed by an appli
ation (in
luding its libraries) after a given memory 
orrup- tion bug has o

urred.</P>
<P class="p45 ft0"><SPAN class="ft0">3.2</SPAN><SPAN class="ft21">Methodology</SPAN></P>
<P class="p25 ft23">Our methodology is based on the use of ptra
e() to debug a pro
ess. We start by either atta
hing to a running pro
ess thanks to its pid, or 
reate a new pro
ess from the 
ommand line of pm
ma.</P>
<P class="p46 ft5">We then wait for the pro
ess to 
rash, emitting a Segmentation Fault 
aught by ptra
e(). This indeed assumes that the user of the pm
ma is able to 
reate an input to 
reate an invalid memory a

ess inside the pro
ess.</P>
<P class="p44 ft5">On any given pro
ess, the amount of mapped memory is limited by ar
hite
ture 
onstraints. In order to verify if overwriting<A href="#page_6"><SPAN class="ft6">4 </SPAN></A>a given double word in memory will in fa
t modify the <SPAN class="ft1"></SPAN>ow of exe
ution, we start by listing all the memory lo
ations that are writable (we 
annot modify non writable lo
ations anyway). This preliminary phase is performed on a memory snapshot, but performing it after a Segmentation Fault allows us to have a binary whi
h looks (in memory) exa
tly like the pro
ess we'd like to exploit from a mapping point of view.</P>
<P class="p44 ft5">We then for
e the debugged appli
ation to fork(). This 
reates a new pro
ess whi
h only di<SPAN class="ft1"></SPAN>ers from the original debugged pro
ess by its pro
ess id. In parti
ular, all the writable memory lo
ations in
luding the heap, or even global data from all the mapped libraries remain exa
tly the same.</P>
<P class="p26 ft4">We then overwrite a given writable lo
ation with a dummy value 
orresponding to a lo
ation non- exe
utable in userland inside the newly 
reated pro
ess (therefore leaving the original pro
ess inta
t, for later use). 0xf1f2f3f4 is a good su
h value<A href="#page_6"><SPAN class="ft6">5</SPAN></A>. We then 
lear the signals re
eived by the newly spawned pro
ess and follow its exe
ution as if a Segmentation Fault didn't just happen.</P>
<P class="p38 ft4">In 
ase exe
ution is transfered to memory lo
ation 0xf1f2f3f4 before the appli
ation exits, we have found a proper fun
tion pointer a
tually dereferen
ed by the appli
ation. This is easily dete
table as it will trigger a SIGSEGV signal (the Segmentation Fault being due to an attempt to exe
ute 
ode in a lo
ation normally reserved to ring 0).</P>
<P class="p47 ft23">If su
h is not the 
ase, we repeat the pro
ess of for
ing the original debugged pro
ess to fork() and overwrite an other memory lo
ation with the same dummy pointer.</P>
<P class="p48 ft5"><SPAN class="ft6">4 </SPAN>simulating the fa
t that the previous ins
tru
tion triggering the Segmentation Fault had led to an arbitrary memory write instead of simply triggering a SEGFAULT...</P>
<P class="p49 ft19"><SPAN class="ft6">5 </SPAN>It is both always pointing to kernel land, regardless of the kernel split in use, and easy to identify.</P>
</DIV>
<DIV id="id6_2">
<P class="p10 ft0">6</P>
</DIV>
</DIV>
<DIV id="page_7">


<DIV id="id7_1">
<P class="p50 ft23">By iterating this way over all of the possible writable memory lo
ations, we 
an <SPAN class="ft0"></SPAN>nd all the fun
tion pointers dereferen
ed by the appli
ation during its normal <SPAN class="ft0"></SPAN>ow of exe
ution.</P>
<P class="p51 ft0"><SPAN class="ft0">3.3</SPAN><SPAN class="ft21">mk_fork() implementation</SPAN></P>
<P class="p33 ft5">Previous works[14<SPAN class="ft0">℄</SPAN><A href="#page_31">[15</A><SPAN class="ft0">℄ </SPAN>have shown it was possible to use ptra
e to inje
t an arbitrary library inside the pro
ess' address spa
e. We don't need that mu
h, we'll just inje
t a small shell
ode for
ing the pro
ess to 
all fork, and start ptra
ing the 
hild.</P>
<P class="p6 ft5">Let's see how this 
an be a
hieved (ignoring error handling here and unne
essary 
omplexity for the sake of 
larity):</P>
<P class="p31 ft24">/*</P>
<P class="p10 ft3">*</P>
<P class="p10 ft3"><SPAN class="ft3">*</SPAN><SPAN class="ft25">for
e a pro
ess to fork()</SPAN></P>
<P class="p52 ft3"><SPAN class="ft3">*</SPAN><SPAN class="ft25">returns the pid of the offspring</SPAN></P>
<P class="p52 ft3">*/</P>
<P class="p10 ft2">int mk_fork(pid_t pid){</P>
<P class="p53 ft3">void *target_addr;</P>
<P class="p54 ft5">stru
t user_regs_stru
t regz; stru
t user_regs_stru
t regs; stru
t user_regs_stru
t regz_new; int status;</P>
<P class="p55 ft3">siginfo_t si;</P>
<P class="p56 ft5">stru
t w_to_x_ptr *tmp4; int newpid;</P>
<P class="p57 ft2">int fork_ok=0,offspring_ok=0;</P>
<P class="p53 ft3">/*</P>
<P class="p58 ft3"><SPAN class="ft3">*</SPAN><SPAN class="ft25">prepare 
hild to perform a fork</SPAN></P>
<P class="p58 ft2">*/</P>
<P class="p53 ft24">// save registers</P>
<P class="p59 ft5">ptra
e(PTRACE_GETREGS, pid,NULL, &regz); mem
py(&regz_new,&regz,sizeof(regz));</P>
<P class="p60 ft24">// ba
kup 
ontent at addr</P>
<P class="p58 ft2">getdata(pid, (int)target_addr, ba
kup_buff, 200);</P>
<P class="p61 ft24">// repla
e with fork_stub shell
ode</P>
<P class="p58 ft2">write_data(pid,(int)target_addr,fork_stub,10);</P>
<P class="p53 ft3">// exe
ute fork_stub</P>
<P class="p62 ft23">regz_new.eip=(int)target_addr+2; ptra
e(PTRACE_SETREGS, pid,NULL, &regz_new);</P>
<P class="p53 ft3">/*</P>
<P class="p63 ft24"><SPAN class="ft24">*</SPAN><SPAN class="ft26">Continue ptra
ing untill we get both a</SPAN></P>
<P class="p63 ft2"><SPAN class="ft2">*</SPAN><SPAN class="ft27">SIGTRAP (parent) or SIGSTOP (
hild)</SPAN></P>
</DIV>
<DIV id="id7_2">
<P class="p10 ft0">7</P>
</DIV>
</DIV>
<DIV id="page_8">
<DIV id="p8dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p8img1"></DIV>


<DIV id="id8_1">
<P class="p64 ft3">*/</P>
<P class="p65 ft5">fork_ok=0; offspring_ok=0; while((!fork_ok)&&(!offspring_ok)){</P>
<P class="p66 ft2">memset(&si, 0, sizeof(siginfo_t));</P>
<P class="p67 ft23">ptra
e(PTRACE_GETREGS, pid,NULL, &regs); ptra
e(PTRACE_SETREGS, pid,NULL, &regs);</P>
<P class="p68 ft5">ptra
e(PTRACE_CONT, pid, NULL, NULL); <NOBR>waitpid(-1,&status,P_ALL); //</NOBR> any pid ptra
e(PTRACE_GETSIGINFO, pid, NULL, &si);</P>
<P class="p69 ft3">// parent ?</P>
<P class="p70 ft5">if(si.si_signo == 5){ fork_ok=1;</P>
<P class="p71 ft3">}</P>
<P class="p66 ft24">// offspring ?</P>
<P class="p72 ft5">if (status &gt;&gt; 16 == PTRACE_EVENT_FORK) { ptra
e(PTRACE_GETEVENTMSG, pid, NULL, (void*) &newpid); ptra
e(PTRACE_SYSCALL, newpid, NULL, NULL);</P>
<P class="p66 ft3">}</P>
<P class="p73 ft2">}</P>
<P class="p74 ft3">/*</P>
<P class="p73 ft24"><SPAN class="ft24">*</SPAN><SPAN class="ft28">Clean up the mess</SPAN></P>
<P class="p73 ft3">*/</P>
<P class="p73 ft24">// 
lear signals</P>
<P class="p75 ft5">memset(&si, 0, sizeof(siginfo_t)); ptra
e(PTRACE_SETSIGINFO, pid, NULL, &si); ptra
e(PTRACE_SETSIGINFO, newpid, NULL, &si);</P>
<P class="p76 ft24">// restore data</P>
<P class="p77 ft23">write_data(pid,(int)target_addr,ba
kup_buff,200); write_data(newpid,(int)target_addr,ba
kup_buff,200);</P>
<P class="p78 ft3">// restore registers</P>
<P class="p79 ft23">ptra
e(PTRACE_SETREGS, pid, NULL, &regz); ptra
e(PTRACE_SETREGS, newpid, NULL, &regz);</P>
<P class="p78 ft24">return newpid;</P>
<P class="p16 ft2">}</P>
<P class="p80 ft5">With fork_stub being a small shell
ode<SPAN class="ft6">6 </SPAN>:</P>
<TABLE cellpadding=0 cellspacing=0 class="t1">
<TR>
	<TD colspan=2 class="tr0 td5"><P class="p12 ft10">;forking shell
ode:</P></TD>
	<TD class="tr0 td6"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td7"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td8"><P class="p12 ft10">00000000</P></TD>
	<TD class="tr3 td9"><P class="p15 ft10">6631C0</P></TD>
	<TD colspan=2 class="tr3 td10"><P class="p12 ft10">xor eax,eax</P></TD>
</TR>
<TR>
	<TD class="tr4 td8"><P class="p12 ft10">00000003</P></TD>
	<TD class="tr4 td9"><P class="p15 ft10">B002</P></TD>
	<TD class="tr4 td6"><P class="p12 ft10">mov</P></TD>
	<TD class="tr4 td7"><P class="p12 ft10">al,0x2</P></TD>
</TR>
<TR>
	<TD class="tr0 td8"><P class="p12 ft2">00000005</P></TD>
	<TD class="tr0 td9"><P class="p15 ft2">CD80</P></TD>
	<TD class="tr0 td6"><P class="p12 ft2">int</P></TD>
	<TD class="tr0 td7"><P class="p12 ft2">0x80</P></TD>
</TR>
</TABLE>
<P class="p27 ft2">followed by 4 bytes 0x

 whi
h will trigger a signal 5 (SIGTRAP) when exe
uted.</P>
<P class="p81 ft5"><SPAN class="ft8">6</SPAN><SPAN class="ft9">The shell
odes in this paper will be given assuming a 32b intel ar
hite
ture for illustrative purpose.</SPAN></P>
</DIV>
<DIV id="id8_2">
<P class="p10 ft0">8</P>
</DIV>
</DIV>
<DIV id="page_9">


<DIV id="id9_1">
<P class="p30 ft5">The operations performed are therefore the following : <SPAN class="ft1"></SPAN>rst of, the state of the registers of the de- bugged appli
ation are saved. Then, 10 bytes from the debugged pro
ess are ba
ked up, starting from target_addr (whi
h is the pla
e we will use to write and exe
ute our small shell
ode. This lo
ation needs to be mapped in an exe
utable lo
ation). Our small shell
ode is then inje
ted inside the running pro
ess. Registers are then modi<SPAN class="ft1"></SPAN>ed in the debugged pro
ess so that the next instru
tion to be exe
uted will be our shell
ode, and 
ontrol is passed to this appli
ation. Upon 
orre
t exe
ution of this shell
ode, we will re
eive two signals : a SIGTRAP emitted by the debugged pro
ess, and a SIGSTOP emitted by its newly 
reated o<SPAN class="ft1"></SPAN>spring. We then restore the 10 bytes ba
ked up earlier in both pro
esses and restore their registers to the their original state.</P>
<P class="p82 ft2">This way, we obtain an almost perfe
t repli
a of our original pro
ess to experiment with at will.</P>
<P class="p83 ft0"><SPAN class="ft0">3.4</SPAN><SPAN class="ft21">Limitations</SPAN></P>
<P class="p84 ft2">.</P>
<P class="p7 ft5">The main limitation is that all of the Inter Pro
ess Communi
ation (IPC) and <SPAN class="ft1"></SPAN>le I/O 
an be assumed to be in unpredi
table state in the 
ontext of the o<SPAN class="ft1"></SPAN>spring. The return of any sys
all is in fa
t un- predi
table. This may 
ause di<SPAN class="ft1"></SPAN>eren
es in the exe
ution of the original pro
ess and the o<SPAN class="ft1"></SPAN>spring. In parti
ular, this may 
ause the o<SPAN class="ft1"></SPAN>spring to exit earlier than the original pro
ess would have be
ause of IPC or sys
all errors, leading to false negatives in our analysis.</P>
<P class="p85 ft23">Experimentally, this experimental te
hnique works well enough to provide rea
hable fun
tion pointers 
alled, even though it still misses many that would exist mu
h later in the <SPAN class="ft1"></SPAN>ow of exe
ution.</P>
<P class="p86 ft5">The system 
alls 
ould probably be re
orded in the original pro
ess and faked in o<SPAN class="ft1"></SPAN>springs to remove those problems entirely, thanks fo the ptra
e() method PTRACE_SYSCALL. And a further 
ost in performan
e. This idea is further des
ribed later in this whitepaper under se
tion 6.5.</P>
<P class="p83 ft0"><SPAN class="ft0">4</SPAN><SPAN class="ft18">Here be dragons : zombie reaping</SPAN></P>
<P class="p87 ft5">The previously des
ribed methodology to 
reate pro
esses is indeed powerful, but 
reating unexpe
ted 
hildren to a pro
ess poses several problems if we intend to debug large appli
ations su
h as network servi
es or web browsers. In this later 
ase, we will need to analyze megabytes of writable data, hen
e 
reate millions of 
hildren. In order to s
ale under those proportions, dealing with the termination of the 
reated o<SPAN class="ft1"></SPAN>springs is mandatory.</P>
<P class="p88 ft0"><SPAN class="ft0">4.1</SPAN><SPAN class="ft21">Dealing with SIGCHLD</SPAN></P>
<P class="p89 ft4">Sin
e the original appli
ation will be kept sleeping while we will 
reate thousands if bot millions of 
hildren to test writes in di<SPAN class="ft1"></SPAN>erent lo
ations, it won't be able to wait() for the return signal (SIGCHLD) emitted by ea
h 
hild pro
ess 
reated when exiting. If we don't solve this situation, all those unre
eived signals will prevent the 
hild pro
esses from a
tually terminating, leaving them in a zombie state.</P>
<P class="p33 ft4">First of, this is a waste of memory and 
pu 
y
les be
ause the zombies still have an entry in say, task_stru
t in kernel land. Those pro
esses will also uselessly keep a pro
ess id, whi
h is a limited resour
e on a 
omputer. On
e all the available pro
ess ids will be attributed to 
hildren pro
esses even- tually ending in zombie states, we will not be able to 
reate new ones at all.</P>
<P class="p7 ft5">The <SPAN class="ft1"></SPAN>rst strategy to avoid zombies is to expli
itly have the original pro
ess ask not to be sent SIGCHLD signals when its o<SPAN class="ft1"></SPAN>springs exit. This is fortunately possible under GNU/Linux by using siga
tion() to ignore SIGCHLD signals. The kernel will then not bother sending signals to our dormant pro
ess.</P>
</DIV>
<DIV id="id9_2">
<P class="p10 ft0">9</P>
</DIV>
</DIV>
<DIV id="page_10">


<DIV id="id10_1">
<P class="p10 ft2">The C 
ode to perform this operation is equivalent to:</P>
<P class="p90 ft5">stru
t siga
tion sa = {.sa_handler = SIG_IGN}; siga
tion(SIGCHLD, &sa, NULL);</P>
<P class="p91 ft5">This 
ode needs to be 
alled only on
e by our original pro
ess. To perform this operation, we use the same inje
tion methodology as with the mk_fork() shell
ode. Our position independent shell
ode stub to perform this system 
all is the following:</P>
<P class="p81 ft3"><SPAN class="ft3">;</SPAN><SPAN class="ft25">Siga
tion shell
ode: // Zombie reaper</SPAN></P>
<P class="p10 ft3"><SPAN class="ft3">;</SPAN><SPAN class="ft25">stru
t siga
tion sa = {.sa_handler = SIG_IGN};</SPAN></P>
<P class="p10 ft2"><SPAN class="ft2">;</SPAN><SPAN class="ft29">siga
tion(SIGCHLD, &sa, NULL);</SPAN></P>
<P class="p49 ft3">_start:</P>
<P class="p92 ft5">nop nop nop nop 
all fake</P>
<TABLE cellpadding=0 cellspacing=0 class="t2">
<TR>
	<TD class="tr0 td11"><P class="p12 ft10">fake:</P></TD>
	<TD class="tr0 td12"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td13"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td8"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td14"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=2 class="tr4 td9"><P class="p93 ft10">pop e
x</P></TD>
	<TD class="tr4 td13"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td8"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td14"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=3 class="tr3 td18"><P class="p93 ft10">add e
x,0x18</P></TD>
	<TD colspan=5 class="tr3 td19"><P class="p94 ft10">; delta to siga
tion stru
ture</P></TD>
	<TD class="tr3 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=2 class="tr5 td9"><P class="p93 ft10">xor eax,eax</P></TD>
	<TD class="tr5 td13"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td8"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td14"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=2 class="tr3 td9"><P class="p93 ft10">mov al,0x43</P></TD>
	<TD class="tr3 td13"><P class="p12 ft11">&nbsp;</P></TD>
	<TD colspan=2 class="tr3 td20"><P class="p94 ft10">; siga
tion</P></TD>
	<TD class="tr3 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=3 class="tr4 td18"><P class="p93 ft10">mov ebx,0x11</P></TD>
	<TD colspan=2 class="tr4 td20"><P class="p94 ft10">; SIGCHLD</P></TD>
	<TD class="tr4 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr4 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=2 class="tr3 td9"><P class="p93 ft10">xor edx,edx</P></TD>
	<TD class="tr3 td13"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td8"><P class="p94 ft10">; 0x00</P></TD>
	<TD class="tr3 td14"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=2 class="tr3 td9"><P class="p93 ft10">int 0x80</P></TD>
	<TD class="tr3 td13"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td8"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td14"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr3 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=4 class="tr5 td21"><P class="p93 ft10">db 0x

, 0x

,0x

,0x

</P></TD>
	<TD class="tr5 td14"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td15"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td16"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=5 class="tr5 td22"><P class="p12 ft10">; stru
t siga
tion sa = {.sa_handler =</P></TD>
	<TD colspan=2 class="tr5 td23"><P class="p95 ft10">SIG_IGN};</P></TD>
	<TD class="tr5 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr5 td13"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr3 td12"><P class="p96 ft10">01, 00,</P></TD>
	<TD class="tr3 td13"><P class="p12 ft10">00,</P></TD>
	<TD colspan=2 class="tr3 td20"><P class="p97 ft10">00, 00, 00, 00,</P></TD>
	<TD class="tr3 td15"><P class="p95 ft10">00,</P></TD>
	<TD class="tr3 td16"><P class="p14 ft10">00, 00,</P></TD>
	<TD class="tr3 td17"><P class="p14 ft10">00, 00, 00,</P></TD>
	<TD class="tr3 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr4 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr4 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD class="tr4 td13"><P class="p12 ft10">00,</P></TD>
	<TD colspan=2 class="tr4 td20"><P class="p97 ft10">00, 00, 00, 00,</P></TD>
	<TD class="tr4 td15"><P class="p95 ft10">00,</P></TD>
	<TD class="tr4 td16"><P class="p14 ft10">00, 00,</P></TD>
	<TD class="tr4 td17"><P class="p14 ft10">00, 00, 00,</P></TD>
	<TD class="tr4 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr3 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr3 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD class="tr3 td13"><P class="p12 ft10">00,</P></TD>
	<TD colspan=2 class="tr3 td20"><P class="p97 ft10">00, 00, 00, 00,</P></TD>
	<TD class="tr3 td15"><P class="p95 ft10">00,</P></TD>
	<TD class="tr3 td16"><P class="p14 ft10">00, 00,</P></TD>
	<TD class="tr3 td17"><P class="p14 ft10">00, 00, 00,</P></TD>
	<TD class="tr3 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr4 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr4 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD class="tr4 td13"><P class="p12 ft10">00,</P></TD>
	<TD colspan=2 class="tr4 td20"><P class="p97 ft10">00, 00, 00, 00,</P></TD>
	<TD class="tr4 td15"><P class="p95 ft10">00,</P></TD>
	<TD colspan=2 class="tr4 td24"><P class="p14 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr4 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr3 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr3 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD colspan=3 class="tr3 td25"><P class="p97 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr3 td15"><P class="p95 ft10">00,</P></TD>
	<TD colspan=2 class="tr3 td24"><P class="p14 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr3 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr3 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr3 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD colspan=3 class="tr3 td25"><P class="p97 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr3 td15"><P class="p95 ft10">00,</P></TD>
	<TD colspan=2 class="tr3 td24"><P class="p14 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr3 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr4 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr4 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD colspan=2 class="tr4 td17"><P class="p12 ft10">00, 00, 00,</P></TD>
	<TD class="tr4 td14"><P class="p97 ft10">00, 00,</P></TD>
	<TD class="tr4 td15"><P class="p95 ft10">00,</P></TD>
	<TD colspan=2 class="tr4 td24"><P class="p14 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr4 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr3 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr3 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD colspan=2 class="tr3 td17"><P class="p12 ft10">00, 00, 00,</P></TD>
	<TD class="tr3 td14"><P class="p97 ft10">00, 00,</P></TD>
	<TD class="tr3 td15"><P class="p95 ft10">00,</P></TD>
	<TD colspan=2 class="tr3 td24"><P class="p14 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr3 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr4 td11"><P class="p93 ft10">db</P></TD>
	<TD class="tr4 td12"><P class="p96 ft10">00, 00,</P></TD>
	<TD colspan=2 class="tr4 td17"><P class="p12 ft10">00, 00, 00,</P></TD>
	<TD class="tr4 td14"><P class="p97 ft10">00, 00,</P></TD>
	<TD class="tr4 td15"><P class="p95 ft10">00,</P></TD>
	<TD colspan=2 class="tr4 td24"><P class="p14 ft10">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr4 td13"><P class="p14 ft10">00</P></TD>
</TR>
<TR>
	<TD class="tr0 td11"><P class="p93 ft2">db</P></TD>
	<TD class="tr0 td12"><P class="p96 ft2">00, 00,</P></TD>
	<TD colspan=2 class="tr0 td17"><P class="p12 ft2">00, 00, 00,</P></TD>
	<TD class="tr0 td14"><P class="p97 ft2">00, 00,</P></TD>
	<TD class="tr0 td15"><P class="p95 ft2">00,</P></TD>
	<TD colspan=2 class="tr0 td24"><P class="p14 ft2">00, 00, 00, 00, 00,</P></TD>
	<TD class="tr0 td13"><P class="p14 ft2">00</P></TD>
</TR>
</TABLE>
<P class="p98 ft4">Using this te
hnique, we don't need to 
are about pending signals anymore. But sin
e our weird de- bugger is spawning so many 
hildren, we need to ensure that those pro
esses a
tually terminate after a given period of time. And that any pro
esses that they'd have spawned themselves without our knowl- edge will also terminate in order to spare 
omputer resour
es.</P>
</DIV>
<DIV id="id10_2">
<P class="p10 ft0">10</P>
</DIV>
</DIV>
<DIV id="page_11">
<DIV id="p11dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p11img1"></DIV>


<P class="p99 ft2"><SPAN class="ft2">4.2</SPAN><SPAN class="ft30">Pro
esses grouping</SPAN></P>
<P class="p100 ft5">POSIX o<SPAN class="ft1"></SPAN>ers a great and little known way to solve this problem. Instead of systra
ing every 
reated 
hildren and hook grand
hildren 
reation, we 
an 
reate pro
ess groups. Those groups are 
reated for instan
e using a 
all to the sys
all setpgid() to 
reate a new group. All the o<SPAN class="ft1"></SPAN>springs of the pro
ess will then belong to this same group. Instead of killing pro
esses one by one, we then kill the whole group using <NOBR>kill(-groupnumber).</NOBR></P>
<P class="p101 ft5">There is a non POSIX but very e<SPAN class="ft1"></SPAN>
ient version of this sys
all under Linux<SPAN class="ft6">7</SPAN>. The prototype of this fun
tion is:</P>
<P class="p102 ft2">int setpgid(pid_t pid, pid_t pgid);</P>
<P class="p103 ft2">The des
ription of this fun
tion, taken from the Linux man page gives:</P>
<P class="p104 ft5">setpgid() sets the PGID of the pro
ess spe
ified by pid to pgid. If pid is zero, then the pro
ess ID of the 
alling pro
ess is used. If pgid is zero, then the PGID of the pro
ess spe
ified by pid is made the same as its pro
ess ID. If setpgid() is used to move a pro
ess from one pro
ess group to another (as is done by some shells when 
reating pipelines), both pro
ess groups must be part of the same session (see setsid(2) and 
redentials(7)). In this 
ase, the pgid spe
ifies an existing pro
ess group to be joined and the session ID of that group must mat
h the session ID of the joining pro
ess.</P>
<P class="p105 ft2">By inje
ting the following setpgid_stub inside a pro
ess, we 
an for
e it to 
reate a new group:</P>
<P class="p103 ft3">;</P>
<P class="p99 ft3"><SPAN class="ft3">;</SPAN><SPAN class="ft25">setpgid(0,0); shell
ode</SPAN></P>
<P class="p103 ft24">_start:</P>
<P class="p106 ft24">nop nop nop nop</P>
<P class="p107 ft5">mov eax,0x39 ; setpgid xor ebx,ebx</P>
<P class="p108 ft5">xor e
x,e
x int 0x80</P>
<P class="p109 ft2">db 0x

, 0x

</P>
<P class="p110 ft23">When 
alled with 0 as a "pgid" group parameter, the pro
ess of the 
alling pro
ess is used as a group id, whi
h is pretty handy as it avoids us to keep tra
k of pids to groups asso
iations.</P>
<P class="p111 ft4">Using this te
hnique in addition to the previous zombie reaping one, we manage to keep the number of running pro
esses arbitrary low even when debugging large appli
ations su
h as web browsers. The Opera web browser (whi
h is 
losed sour
e) was for instan
e debugged this way to analyze <NOBR>CVE-2011-</NOBR> 1824[16<SPAN class="ft1">℄</SPAN>.</P>
<P class="p112 ft5"><SPAN class="ft8">7</SPAN><SPAN class="ft9">Confere "man 2 setpgid" for di</SPAN><SPAN class="ft1"></SPAN>eren
es.</P>
</DIV>
<DIV id="page_12">
<DIV id="p12dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p12img1"></DIV>


<DIV id="id12_1">
<P class="p16 ft0"><SPAN class="ft0">5</SPAN><SPAN class="ft18">Exploiting invalid memory writes</SPAN></P>
<P class="p113 ft5">In this 
hapter, we will des
ribe how pm
ma 
an be used to help exploit di<SPAN class="ft1"></SPAN>erent sub
lasses of invalid memory writes. We will start with the study of fully 
ontrolled invalid memory writes, where an atta
ker 
ontrols both the destination where to write to, and the 
ontent being written fully. We will then envisage other 
lasses of bugs, where the atta
ker has less degrees of liberty : the 
ase of over<SPAN class="ft1"></SPAN>ows in di<SPAN class="ft1"></SPAN>erent writable se
tions, then the one where the atta
ker doesn't 
ontrol the data being written, and the spe
ial sub 
ase of aligned memory writes.</P>
<P class="p114 ft2"><SPAN class="ft2">5.1</SPAN><SPAN class="ft30">Finding all the fun
tion pointers dereferen
ed after an invalid write</SPAN></P>
<P class="p26 ft5">Pm
ma 
an be run in two fashions in order to perform an analysis. The <SPAN class="ft1"></SPAN>rst one is to atta
h to a running pro
ess by providing its pid at the 
ommand line. It is parti
ularly suited when auditing pro
esses like network daemons. The se
ond one is by providing pm
ma the path of an ELF binary and a 
ommand line arguments to provide it. In both 
ases, in its default mode, pm
ma will then wait for a segmentation fault to start its analysis.</P>
<P class="p115 ft2"><SPAN class="ft2">5.2</SPAN><SPAN class="ft30">Over</SPAN><SPAN class="ft1"></SPAN>ows</P>
<P class="p116 ft4">Over<SPAN class="ft1"></SPAN>ows 
an be seen as a sub
lass of arbitrary writes where the write operation is performed sequen- tially over a given number of bytes (the size of the over<SPAN class="ft1"></SPAN>ow). As opposed to the previous sub
lass of bugs, the atta
ker doesn't get to 
hose where the overwrite is performed. They may though, be able to 
ontrol the size of the over<SPAN class="ft1"></SPAN>ow and the 
ontent being overwritten.</P>
<P class="p37 ft5">Assuming the atta
ker has 
ontrol on both the length of the over<SPAN class="ft1"></SPAN>ow and the data overwritten, limiting the s
ope of the previous audit to the one se
tion being overwritten will <SPAN class="ft1"></SPAN>nd all the relevant fun
tion pointers potentially overwritten.</P>
<P class="p117 ft2">More exploitation strategies are mentioned later in this paper in 
ase su
h a pointer 
ould not be found.</P>
<P class="p118 ft2"><SPAN class="ft2">5.3</SPAN><SPAN class="ft30">Partial overwrites and pointers trun
ations</SPAN></P>
<P class="p116 ft4">Another 
ommon 
ase happens when an atta
ker 
ontrols fully the lo
ation of the write, but has no 
ontrol over the values being written. The ta
ti
 then used in order to a
hieve 
ontrol <SPAN class="ft1"></SPAN>ow hija
king is to attempt to overwrite a fun
tion pointer only partially. This te
hnique is referred in the literature as pointer trun
ation.</P>
<P class="p37 ft5">Depending on the (un
ontrolled, hopefully repeatable) value of the data being written, an atta
ker 
an attempt to perform either a lower bytes overwrite or a upper bytes overwrite. The goal is that on
e modi<SPAN class="ft1"></SPAN>ed, the new fun
tion pointer still points to a memory se
tion mapped as exe
utable.</P>
<P class="p119 ft4">In 
ase the trun
ated fun
tion pointer points to the same se
tion as the original one (typi
ally several bytes before or after), this de fa
to implies that the se
tion is both writable and exe
utable<A href="#page_12"><SPAN class="ft6">8</SPAN></A>. Obtaining arbitrary 
ode exe
ution is then a matter of having an appropriate shell
ode, possibly pre
eded by a nop sled, mapped at the destination address of the modi<SPAN class="ft1"></SPAN>ed pointer.</P>
<P class="p37 ft5">In 
ase the trun
ated pointer points to a di<SPAN class="ft1"></SPAN>erent se
tion, and parti
ularly when it is modi<SPAN class="ft1"></SPAN>ed to point to a se
tion whi
h is exe
utable but not writable (su
h as the .text of a library or of the main binary itself), 
ontrol will be transfered to a lo
ation whi
h has very little 
han
es to hold user 
ontrolled op
odes. In other words, the behavior of the binary from this point is totally not predi
table. That being said, as a last resort strategy, it may be a good option to an atta
ker in the hope of triggering almost immediately an other invalid memory a

ess (whi
h is very likely), and that this se
ond indire
t</P>
<P class="p120 ft5"><SPAN class="ft8">8</SPAN><SPAN class="ft9">Su
h mappings still do exist on a
tual distributions, but the more hardened ones, having a better kernel in terms of se
urity, 
an prevent su
h mappings entirely.</SPAN></P>
</DIV>
<DIV id="id12_2">
<P class="p10 ft0">12</P>
</DIV>
</DIV>
<DIV id="page_13">
<DIV id="p13dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p13img1"></DIV>


<DIV id="id13_1">
<P class="p43 ft4">vulnerability will give him more 
ontrol over the data being possibly written (this is not granted and is largely unpredi
table). For this to happen in a deterministi
 fashion though, the return address has to remain un
hanged between di<SPAN class="ft1"></SPAN>erent mappings due to ASLR. This is quite possible in theory, for instan
e by returning to a <SPAN class="ft1"></SPAN>x .text lo
ation in a non PIE binary.</P>
<P class="p121 ft5">It is worth noting that being able to write only the value 0x00000000 is a very 
ommon su
h s
enario. In parti
ular, integer over<SPAN class="ft1"></SPAN>ows o

urring in iteration 
ounters of 
opy loops typi
ally allow an atta
ker to write passed the intended limits of a write, possibly to arbitrary lo
ations. But the data being written then often 
omes from se
tion paddings be
ause a given 
opy is taking bytes passed the last mapped bu<SPAN class="ft1"></SPAN>er of a se
tion to <NOBR>re-write</NOBR> them at another lo
ation.</P>
<P class="p113 ft4">Pm
ma allows for automati
 testing of the above <NOBR>sub-
ases,</NOBR> taking into a

ount both lower bytes and higher bytes trun
ations. After 
olle
ting informations over the mapping of ea
h se
tion of the binary, in
luding its permissions, and listing the existing fun
tion pointers, it is able to determine whi
h ones are trun
able to point to mapped memory, even a
ross se
tions :</P>
<P class="p45 ft2"><NOBR>--[</NOBR> Validating fun
tion pointers (relaxed mode):</P>
<P class="p122 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xbfb7ef4
 (full 
ontrol flow hija
k) 0xbfb7ef4
 <NOBR>--&gt;</NOBR> 0x080e5e58 // repeatability:0/100</P>
<P class="p123 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xbfb80fe
 (full 
ontrol flow hija
k) 0xbfb80fe
 <NOBR>--&gt;</NOBR> 0x080e5fa2 // repeatability:0/100</P>
<P class="p123 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xbfb8101
 (full 
ontrol flow hija
k) 0xbfb8101
 <NOBR>--&gt;</NOBR> 0x0804f94d // repeatability:0/100</P>
<P class="p124 ft2">...</P>
<P class="p122 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xbfb7ef4
 (full 
ontrol flow hija
k) 0xbfb7ef4
 <NOBR>--&gt;</NOBR> 0x080e5e58 // repeatability:0/100</P>
<P class="p123 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xbfb80fe
 (full 
ontrol flow hija
k) 0xbfb80fe
 <NOBR>--&gt;</NOBR> 0x080e5ea2 // repeatability:0/100</P>
<P class="p125 ft3"><NOBR>--&gt;</NOBR> total : 186 validated fun
tion pointers</P>
<TABLE cellpadding=0 cellspacing=0 class="t3">
<TR>
	<TD class="tr0 td26"><P class="p96 ft10">(and found 8 additional 
ontrol flow errors)</P></TD>
	<TD class="tr0 td27"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td28"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD colspan=2 class="tr5 td29"><P class="p12 ft10"><NOBR>--[</NOBR> Fun
tion pointers exploitable by trun
ation with 0x41424344:</P></TD>
	<TD class="tr5 td28"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td26"><P class="p96 ft10">At 0xb70
e070 : 0xb70
63
2 will be
ome 0xb70
4142 (lower</P></TD>
	<TD colspan=2 class="tr3 td30"><P class="p12 ft10">trun
ated by 16 bits, dest perms:RW)</P></TD>
</TR>
<TR>
	<TD class="tr3 td26"><P class="p96 ft10">At 0xb70e40a4 : 0xb70
a8f2 will be
ome 0xb70
4142 (lower</P></TD>
	<TD colspan=2 class="tr3 td30"><P class="p12 ft10">trun
ated by 16 bits, dest perms:RW)</P></TD>
</TR>
<TR>
	<TD class="tr4 td26"><P class="p96 ft10">At 0xb70e
080 : 0xb70e5e02 will be
ome 0xb70e4142 (lower</P></TD>
	<TD colspan=2 class="tr4 td30"><P class="p12 ft10">trun
ated by 16 bits, dest perms:RW)</P></TD>
</TR>
<TR>
	<TD class="tr3 td26"><P class="p96 ft10">At 0xb731a030 : 0xb7315da2 will be
ome 0xb7314142 (lower</P></TD>
	<TD colspan=2 class="tr3 td30"><P class="p12 ft10">trun
ated by 16 bits, dest perms:RW)</P></TD>
</TR>
<TR>
	<TD class="tr4 td26"><P class="p96 ft10">At 0xb73230a4 : 0xb732003a will be
ome 0xb7324142 (lower</P></TD>
	<TD class="tr4 td27"><P class="p12 ft10">trun
ated by 16</P></TD>
	<TD class="tr4 td28"><P class="p12 ft10">bits, dest perms:RW)</P></TD>
</TR>
<TR>
	<TD class="tr3 td26"><P class="p96 ft10">At 0xb732803
 : 0xb7325a36 will be
ome 0xb7324142 (lower</P></TD>
	<TD class="tr3 td27"><P class="p12 ft10">trun
ated by 16</P></TD>
	<TD class="tr3 td28"><P class="p12 ft10">bits, dest perms:RW)</P></TD>
</TR>
<TR>
	<TD class="tr0 td26"><P class="p96 ft2">At 0xb76a80d8 : 0xb7325bf0 will be
ome 0xb7324142 (lower</P></TD>
	<TD class="tr0 td27"><P class="p12 ft2">trun
ated by 16</P></TD>
	<TD class="tr0 td28"><P class="p12 ft2">bits, dest perms:RW)</P></TD>
</TR>
</TABLE>
<P class="p17 ft4">In the previous example taken from an analysis on the text editor nedit under Ubuntu 10.10, 186 fun
tion pointers a
tually dereferen
ed were found, after the starting point of the analysis. Assuming that the value being written is not 
ontrolled and is (0x41424344)<A href="#page_13"><SPAN class="ft6">9</SPAN></A>, 7 of them 
an be trun
ated to point to valid memory. In this run, the destination permission was always reported as "RW", that is both</P>
<P class="p126 ft13"><SPAN class="ft8">9</SPAN><SPAN class="ft17">This value is 
on</SPAN><SPAN class="ft1"></SPAN>gurable from the 
ommand line, and pm
ma 
an also use the value a
tually being written during the invalid memory a

ess leading to the <SPAN class="ft1"></SPAN>rst segmentation fault - this is the default.</P>
</DIV>
<DIV id="id13_2">
<P class="p10 ft0">13</P>
</DIV>
</DIV>
<DIV id="page_14">


<DIV id="id14_1">
<P class="p127 ft19">Readable and Writable. In 
ase the 
urrent kernel allowed exe
ution of se
tions mapped as writable but not expli
itly <SPAN class="ft1"></SPAN>agged as writable (id est: the kernel doesn't support the NX feature and doesn't emulate for this appli
ation), having a shell
ode stored at either 0xb70e4142 or 0xb7324142 will result in arbitrary 
ode exe
ution.</P>
<P class="p128 ft24">For the seek of 
ompleteness, here is an other example, performed this time with a trun
ation by</P>
<P class="p129 ft2">0x00000000 on 4b aligned addresses, on /bin/sudo:</P>
<P class="p130 ft3"><NOBR>--[</NOBR> Fun
tion pointers possibly exploitable by 4 byte aligned trun
ation with 0x00000000:</P>
<TABLE cellpadding=0 cellspacing=0 class="t4">
<TR>
	<TD class="tr0 td31"><P class="p12 ft10">At 0x08067135 : 0x4008039e will</P></TD>
	<TD class="tr0 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr0 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr0 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08067b29 : 0x40080637 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08067b69 : 0x40080639 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08067d89 : 0x4007a933 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8a03d : 0x4007a7a2 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a8a059 : 0x4007a7a5 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8a241 : 0x4007a7a0 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a8a581 : 0x4007a7a0 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8b351 : 0x4000013e will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8b90a : 0x40004042 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">16</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a8
361 : 0x4007a7
3 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8
761 : 0x4007a7
7 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a8
861 : 0x4007a7
8 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8
aa1 : 0x4007a7bd will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8d00a : 0x400007a8 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">16</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a8d1b9 : 0x4007a7d1 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8d245 : 0x4000006f will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a8d2a2 : 0x400a0001 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x400a0000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">16</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8d2
5 : 0x4007a7d2 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a8d2
d : 0x404e1
d5 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a944e1 : 0x4007a952 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a949e5 : 0x40403fbf will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr3 td13"><P class="p131 ft10">24</P></TD>
	<TD class="tr3 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a94b03 : 0x40449040 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40449000 (lower trun
ated by</P></TD>
	<TD colspan=2 class="tr3 td34"><P class="p131 ft10">8 bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a94e02 : 0x4000404a will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40000000 (lower trun
ated by</P></TD>
	<TD class="tr4 td13"><P class="p131 ft10">16</P></TD>
	<TD class="tr4 td33"><P class="p131 ft10">bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a95067 : 0x40415
40 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40415
00 (lower trun
ated by</P></TD>
	<TD colspan=2 class="tr3 td34"><P class="p131 ft10">8 bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr4 td31"><P class="p12 ft10">At 0x08a95077 : 0x40415040 will</P></TD>
	<TD class="tr4 td32"><P class="p12 ft10">be
ome 0x40415000 (lower trun
ated by</P></TD>
	<TD colspan=2 class="tr4 td34"><P class="p131 ft10">8 bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr3 td31"><P class="p12 ft10">At 0x08a95087 : 0x40414640 will</P></TD>
	<TD class="tr3 td32"><P class="p12 ft10">be
ome 0x40414600 (lower trun
ated by</P></TD>
	<TD colspan=2 class="tr3 td34"><P class="p131 ft10">8 bits, dest perms:RX)</P></TD>
</TR>
<TR>
	<TD class="tr0 td31"><P class="p12 ft2">...</P></TD>
	<TD class="tr0 td32"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td13"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td33"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
</TABLE>
<P class="p132 ft5">We 
an verify that this time, trun
ations of di<SPAN class="ft1"></SPAN>erent sizes are possible, and that the destination address would be readable and exe
utable. It 
orresponds to the .text of shared libraries, and returning there, while almost<A href="#page_14"><SPAN class="ft6">10 </SPAN></A>guaranteed to lead to exe
ution of exe
utable 
ode. But the result of returning savagely to an unexpe
ted lo
ation is entirely non predi
table and needs be tested, for instan
e using an other iteration of pm
ma.</P>
<P class="p133 ft5"><SPAN class="ft31">10</SPAN><SPAN class="ft32">It is in fa
t</SPAN> possible in theory to return to the middle of an op
ode, hen
e 
orresponding to an invalid instru
tion</P>
</DIV>
<DIV id="id14_2">
<P class="p10 ft0">14</P>
</DIV>
</DIV>
<DIV id="page_15">


<DIV id="id15_1">
<P class="p10 ft2"><SPAN class="ft2">5.4</SPAN><SPAN class="ft30">Dis
overing unaligned memory reads</SPAN></P>
<P class="p134 ft5">Last but not least, an extreme <NOBR>sub-
ase</NOBR> of overwrites o

urs when an atta
ker has not only no or little 
ontrol over the data being written, but has additional 
onstraints over where the write lo
ation is being performed. The author found himself in su
h a situation where only the value 0x00000000 
ould be written, and only on 4 byte aligned lo
ations. This atypi
al 
ase was due to a 
opy loop where the destination was user 
ontrolled be
ause of an integer over<SPAN class="ft1"></SPAN>ow, but where the destination would always be a multiple of 4 (many su
h memory initialization or 
opy loops pro
ess 4byte aligned memory zones, be
ause 
ompilers try to keep the data aligned in order to maximize 
pu e<SPAN class="ft1"></SPAN>
ien
y, and be
ause the size of an atomi
 
opy is also a multiple of 4).</P>
<P class="p9 ft5">Most fun
tion pointers inside an appli
ation are aligned on 4 byte boundaries. In this 
ase, in<SPAN class="ft1"></SPAN>uen
ing the <SPAN class="ft1"></SPAN>ow of exe
ution by trun
ating a fun
tion pointer like previously is not possible, due to the ad- ditional 
onstraints on the destination. In 
ase we found an unaligned fun
tion pointer, this 
ould be pra
ti
al. Therefore, whenever an unaligned fun
tion pointer is found, pm
ma <SPAN class="ft1"></SPAN>ags it as remarkable (but this is honestly quite rare on Intel ar
hite
tures).</P>
<P class="p135 ft5">In 
ase no su
h unaligned fun
tion pointers 
ould be found, those highly 
hallenging memory 
orruption bugs would probably be regarded as never exploitable by most exploit writters. In fa
t, we believe they may still be used to in<SPAN class="ft1"></SPAN>uen
e the 
ontrol <SPAN class="ft1"></SPAN>ow of exe
ution, but indire
tly.</P>
<P class="p32 ft4">Sin
e an atta
ker 
an under those 
onditions only alter data 4b aligned to be 0x00000000, whi
h has little 
han
es of being interesting, the idea is to manage to overwrite partially a given double word in memory that will later be read using an unaligned read by the 
pu. Su
h unaligned reads are fairly rare, but 
an be listed using a unique te
hnique we developped for pm
ma.</P>
<P class="p136 ft2">The following 
ode performs those operations:</P>
<P class="p137 ft5">int monitor_unaligned(int pid){ stru
t user_regs_stru
t regz;</P>
<P class="p138 ft3">keepexe
:</P>
<P class="p139 ft3">// Set align flag</P>
<P class="p140 ft5">ptra
e(PTRACE_GETREGS, pid,NULL, &regz); regz.eflags |=0x40000; ptra
e(PTRACE_SETREGS, pid,NULL, &regz);</P>
<P class="p141 ft5">while(1){ siginfo_t si;</P>
<P class="p142 ft2">memset(&si, 0, sizeof(siginfo_t));</P>
<P class="p143 ft24">// 
ontinue tra
ing</P>
<P class="p144 ft5">ptra
e(PTRACE_CONT, pid, NULL, NULL); wait(NULL);</P>
<P class="p145 ft3">// display re
eived signals</P>
<P class="p146 ft5">ptra
e(PTRACE_GETSIGINFO, pid, NULL, &si); last_signal=si.si_signo;</P>
<P class="p147 ft3">siginfo_t si;</P>
<P class="p148 ft2">memset(&si, 0, sizeof(siginfo_t));</P>
<P class="p149 ft3">// void error</P>
<P class="p150 ft23">memset(&si, 0, sizeof(siginfo_t)); ptra
e(PTRACE_SETSIGINFO, pid, NULL, &si);</P>
</DIV>
<DIV id="id15_2">
<P class="p10 ft0">15</P>
</DIV>
</DIV>
<DIV id="page_16">


<DIV id="id16_1">
<P class="p151 ft5"><SPAN class="ft5">//</SPAN><SPAN class="ft33">disassemble at 
urrent eip 
har raw[40</SPAN><SPAN class="ft34">℄</SPAN>; memset(raw,0x00,40);</P>
<P class="p152 ft2">getdata(pid, regz.eip, raw, 40);</P>
<P class="p149 ft3">
har line[400<SPAN class="ft34">℄</SPAN>;</P>
<P class="p148 ft2">x86_insn_t insn;/* instru
tion */</P>
<P class="p149 ft2">memset(line,0x00,400);</P>
<P class="p153 ft23">x86_disasm((unsigned 
har*)raw, 40, 40, 0x00, &insn ); x86_format_insn(&insn, line, sizeof line,intel_syntax);</P>
<P class="p149 ft24">if(strlen(line)&gt;1){</P>
<P class="p154 ft3">printf("%08X: %s\n",(unsigned int)regz.eip,line);</P>
<P class="p148 ft2">}</P>
<P class="p155 ft23"><SPAN class="ft23">//</SPAN><SPAN class="ft35">display registers display_regs(line,regz);</SPAN></P>
<P class="p156 ft4"><SPAN class="ft4">//</SPAN><SPAN class="ft36">set eip to next instru
tion ptra
e(PTRACE_GETREGS, pid,NULL, &regz); regz.eip+=insn.size; ptra
e(PTRACE_SETREGS, pid,NULL, &regz);</SPAN></P>
<P class="p143 ft3"><SPAN class="ft3">//</SPAN><SPAN class="ft25">void error</SPAN></P>
<P class="p150 ft3">memset(&si, 0, sizeof(siginfo_t)); ptra
e(PTRACE_SETSIGINFO, pid, NULL, &si);</P>
<P class="p157 ft24">goto keepexe
;</P>
<P class="p139 ft2">}</P>
<P class="p158 ft3">return 0;</P>
<P class="p10 ft2">}</P>
<P class="p159 ft5">The idea is to set the unaligned <SPAN class="ft0"></SPAN>ag in the EFLAGS register so that any subsequent unaligned memory a

ess triggers a signal 7 (Bus Error), as per the intel manuals[17<SPAN class="ft0">℄</SPAN>. By then disassembing the latest instru
tion exe
uted, parsing it to retrieve the registers used and performing a 
all to ptra
e() using the PTRACE_GETREGS request, pm
ma is able to retrieve the address of all unaligned reads and writes.</P>
<P class="p86 ft3">The following example shows how determining all the unaligned memory read and write a

ess 
ould be performed against the OpenSSH daemon running on a Fedora 15 
omputer.</P>
<TABLE cellpadding=0 cellspacing=0 class="t5">
<TR>
	<TD colspan=5 class="tr0 td35"><P class="p12 ft10"><NOBR>[root<SPAN class="ft34"></SPAN>fedora-box</NOBR> pm
ma<SPAN class="ft34">℄</SPAN># netstat <NOBR>-atnp|grep</NOBR> ssh</P></TD>
	<TD class="tr0 td17"><P class="p12 ft11">&nbsp;</P></TD>
	<TD class="tr0 td36"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td7"><P class="p12 ft10">t
p</P></TD>
	<TD class="tr4 td3"><P class="p14 ft10">0</P></TD>
	<TD class="tr4 td7"><P class="p14 ft10">0</P></TD>
	<TD class="tr4 td37"><P class="p160 ft10">0.0.0.0:22</P></TD>
	<TD class="tr4 td38"><P class="p161 ft10">0.0.0.0:*</P></TD>
	<TD class="tr4 td17"><P class="p12 ft10">LISTEN</P></TD>
	<TD class="tr4 td36"><P class="p12 ft10">7619/sshd</P></TD>
</TR>
<TR>
	<TD class="tr3 td7"><P class="p12 ft24">t
p</P></TD>
	<TD class="tr3 td3"><P class="p14 ft24">0</P></TD>
	<TD class="tr3 td7"><P class="p14 ft24">0</P></TD>
	<TD class="tr3 td37"><P class="p160 ft24">:::22</P></TD>
	<TD class="tr3 td38"><P class="p161 ft24">:::*</P></TD>
	<TD class="tr3 td17"><P class="p12 ft24">LISTEN</P></TD>
	<TD class="tr3 td36"><P class="p12 ft24">7619/sshd</P></TD>
</TR>
</TABLE>
<P class="p10 ft2"><NOBR>[root<SPAN class="ft34"></SPAN>fedora-box</NOBR> pm
ma<SPAN class="ft34">℄</SPAN>#</P>
</DIV>
<DIV id="id16_2">
<P class="p10 ft0">16</P>
</DIV>
</DIV>
<DIV id="page_17">


<DIV id="id17_1">
<P class="p10 ft2">In a se
ond terminal, the auditor initiates a ssh 
onne
tion :</P>
<P class="p162 ft2"><NOBR>[endrazine<SPAN class="ft34"></SPAN>fedora-box</NOBR> ~<SPAN class="ft34">℄</SPAN>$ ssh lo
alhost</P>
<P class="p163 ft3">On the <SPAN class="ft1"></SPAN>rst terminal are then listed all the unaligned memory a

esses, along with the relevant infor- mation regarding the instru
tion exe
uted and the value of registers during ea
h a

ess:</P>
<TABLE cellpadding=0 cellspacing=0 class="t6">
<TR>
	<TD class="tr0 td39"><P class="p12 ft10">signo: 7 errno:</P></TD>
	<TD class="tr0 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p12 ft10">00BD9FDF: mov</P></TD>
	<TD class="tr4 td40"><P class="p12 ft10"><NOBR>[edx-0x4<SPAN class="ft34">℄</SPAN>,</NOBR> e
x</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 00000000</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">edx= 214e57b6</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BDA336: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">e
x, [eax+0x6<SPAN class="ft34">℄</SPAN></P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">eax= bfb3
b08</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 0000000a</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p12 ft10">00BDA339: mov</P></TD>
	<TD class="tr4 td40"><P class="p12 ft10">[edx+0x6<SPAN class="ft34">℄</SPAN>, e
x</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 
ae03591</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">edx= 214e20

</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BDA33C: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">e
x, [eax+0x2<SPAN class="ft34">℄</SPAN></P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">eax= bfb3
b08</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 
ae03591</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr4 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BDA33F: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">[edx+0x2<SPAN class="ft34">℄</SPAN>, e
x</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 60000000</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">edx= 214e20

</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p12 ft10">00BDA336: mov</P></TD>
	<TD class="tr4 td40"><P class="p12 ft10">e
x, [eax+0x6<SPAN class="ft34">℄</SPAN></P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">eax= 002beb49</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 0000000a</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr4 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BDA33C: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">e
x, [eax+0x2<SPAN class="ft34">℄</SPAN></P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">eax= 002beb49</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">e
x= b09f2035</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD colspan=2 class="tr4 td41"><P class="p12 ft10">00BDA342: movzx e
x, [eax<SPAN class="ft34">℄</SPAN></P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">eax= 002beb49</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 4a33dae7</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr4 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BD5A55: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10"><NOBR>[edx-0x3<SPAN class="ft34">℄</SPAN>,</NOBR> ax</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">edx= 214e20e4</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BDA339: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">[edx+0x6<SPAN class="ft34">℄</SPAN>, e
x</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">e
x= 00
34ff4</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">edx= 214e20
8</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr4 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BDA33F: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">[edx+0x2<SPAN class="ft34">℄</SPAN>, e
x</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">e
x= 00002d58</P></TD>
	<TD class="tr3 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td39"><P class="p164 ft10">edx= 214e20
8</P></TD>
	<TD class="tr4 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p164 ft10">signo: 7 errno:</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">0 
ode: 1</P></TD>
</TR>
<TR>
	<TD class="tr3 td39"><P class="p12 ft10">00BDA336: mov</P></TD>
	<TD class="tr3 td40"><P class="p12 ft10">e
x, [eax+0x6<SPAN class="ft34">℄</SPAN></P></TD>
</TR>
<TR>
	<TD class="tr0 td39"><P class="p164 ft2">eax= 002beb53</P></TD>
	<TD class="tr0 td40"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
</TABLE>
</DIV>
<DIV id="id17_2">
<P class="p10 ft0">17</P>
</DIV>
</DIV>
<DIV id="page_18">


<DIV id="id18_1">
<P class="p165 ft3">e
x= 0000000a</P>
<P class="p10 ft3">signo: 7 errno: 0 
ode: 1</P>
<P class="p166 ft5">00BDA33C: mov e
x, [eax+0x2<SPAN class="ft34">℄ </SPAN>eax= 002beb53</P>
<P class="p167 ft24">e
x= 382b
34a</P>
<P class="p10 ft3">signo: 7 errno: 0 
ode: 1</P>
<P class="p168 ft24">00BDA342: movzx e
x, [eax<SPAN class="ft34">℄ </SPAN>eax= 002beb53</P>
<P class="p169 ft3">e
x= 5b802b3e</P>
<P class="p10 ft24">signo: 7 errno: 0 
ode: 1</P>
<P class="p166 ft5">00BD5A52: mov <NOBR>[edx-0x7<SPAN class="ft34">℄</SPAN>,</NOBR> eax eax= 00000000</P>
<P class="p170 ft24">edx= 214e20e4</P>
<P class="p10 ft3">signo: 7 errno: 0 
ode: 1</P>
<P class="p171 ft5">00BD5A55: mov <NOBR>[edx-0x3<SPAN class="ft34">℄</SPAN>,</NOBR> ax edx= 214e20e4</P>
<P class="p172 ft3">signo: 7 errno: 0 
ode: 1</P>
<P class="p166 ft5">00BD5A52: mov <NOBR>[edx-0x7<SPAN class="ft34">℄</SPAN>,</NOBR> eax eax= 00000000</P>
<P class="p167 ft3">edx= 214e20e4</P>
<P class="p10 ft24">signo: 7 errno: 0 
ode: 1</P>
<P class="p171 ft5">00BD5A55: mov <NOBR>[edx-0x3<SPAN class="ft34">℄</SPAN>,</NOBR> ax edx= 214e20e4</P>
<P class="p173 ft5">Even if su
h unaligned memory a

esses are rare, writing 0x00000000 to partially modify a 32 bits value that will then be read using an unaligned read 
an trigger se
ondary bugs inside the appli
ations, possibly giving more 
ontrol over the registers used in this se
ond operation to an atta
ker.</P>
<P class="p174 ft0"><SPAN class="ft0">6</SPAN><SPAN class="ft18">ASLR and its limits</SPAN></P>
<P class="p33 ft5">ASLR is a pretty e<SPAN class="ft1"></SPAN>e
tive way to prevent exploitation, based on statisti
s. If an atta
ker 
an make only a single try, for instan
e when exploiting a 
lient side vulnerability, and if ASLR is fully enfor
ed, then it may a
t as a very e<SPAN class="ft1"></SPAN>e
tive mitigation. The publi
ly available debugging tools usually la
k se
tion based ASLR testing,and when they have this feature, su
h as paxtest, they la
k the 
apability to test the ASLR of a given binary in its entirety. In this 
hapter, we indent to outline a few limits of ASLR as well as des
ribe how ASLR testing has been implemented in pm
ma.</P>
<P class="p175 ft2"><SPAN class="ft2">6.1</SPAN><SPAN class="ft30">E</SPAN><SPAN class="ft1"></SPAN>e
tive testing of ASLR</P>
<P class="p176 ft5">As the astute reader may have noti
ed from previous examples, when reporting a <SPAN class="ft1"></SPAN>nding, pm
ma systemati
ally appends a metri
 of repeatability, su
h as:</P>
<P class="p177 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xbfb7ef4
 (full 
ontrol flow hija
k) 0xbfb7ef4
 <NOBR>--&gt;</NOBR> 0x080e5e58 // repeatability:0/100</P>
<P class="p172 ft3">...</P>
<P class="p178 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xb76f
4b
 (full 
ontrol flow hija
k) 0xb76f
4b
 <NOBR>--&gt;</NOBR> 0xb76
3e20 // repeatability:0/100</P>
<P class="p179 ft2">This metri
 a
tually re<SPAN class="ft1"></SPAN>e
ts the probability of a given mapping to reo

ur at the very same lo
ation.</P>
<P class="p180 ft4">In order to 
ompute those probabilities, pm
ma starts by relaun
hing the target binary a great number of times (100 by default). For ea
h exe
ution, it re
ords the base address of the mapping of ea
h se
tion. The metri
 displayed along with <SPAN class="ft1"></SPAN>ndings is then the highest probability to <SPAN class="ft1"></SPAN>nd a given se
tion at a parti
ular address:</P>
</DIV>
<DIV id="id18_2">
<P class="p10 ft0">18</P>
</DIV>
</DIV>
<DIV id="page_19">


<DIV id="id19_1">
<P class="p10 ft3"><NOBR>--[</NOBR> Performing ASLR tests:</P>
<P class="p10 ft3">[se
tion:001<SPAN class="ft34">℄ </SPAN>/bin/su</P>
<P class="p181 ft24">most probable address:0x08048000, proba=100/100</P>
<P class="p10 ft3">[se
tion:002<SPAN class="ft34">℄ </SPAN>/bin/su</P>
<P class="p181 ft24">most probable address:0x0804f000, proba=100/100</P>
<P class="p10 ft3">[se
tion:003<SPAN class="ft34">℄ </SPAN>/bin/su</P>
<P class="p182 ft5">most probable address:0x08050000, proba=100/100 [se
tion:004<SPAN class="ft34">℄</SPAN></P>
<P class="p183 ft3">most probable address:0x08051000, proba=100/100</P>
<P class="p10 ft24">[se
tion:005<SPAN class="ft34">℄ </SPAN>[heap<SPAN class="ft34">℄</SPAN></P>
<P class="p181 ft3">most probable address:0x0805e000, proba&lt;001/100</P>
<P class="p10 ft3"><NOBR>[se
tion:006<SPAN class="ft34">℄ </SPAN>/lib/ld-2.12.1.so</NOBR></P>
<P class="p181 ft24">most probable address:0xb7583000, proba&lt;002/100</P>
<P class="p10 ft3"><NOBR>[se
tion:007<SPAN class="ft34">℄ </SPAN>/lib/ld-2.12.1.so</NOBR></P>
<P class="p181 ft24">most probable address:0xb7584000, proba&lt;002/100</P>
<P class="p10 ft3"><NOBR>[se
tion:008<SPAN class="ft34">℄ </SPAN>/lib/ld-2.12.1.so</NOBR></P>
<P class="p181 ft3">most probable address:0xb758d000, proba&lt;002/100</P>
<P class="p10 ft24">[se
tion:009<SPAN class="ft34">℄ </SPAN>[vdso<SPAN class="ft34">℄</SPAN></P>
<P class="p182 ft5">most probable address:0xb758e000, proba&lt;002/100 [se
tion:010<SPAN class="ft34">℄</SPAN></P>
<P class="p184 ft24">most probable address:0xb758f000, proba&lt;002/100</P>
<P class="p185 ft24"><NOBR>[se
tion:011<SPAN class="ft34">℄ </SPAN>/usr/lib/lo
ale/lo
ale-ar
hive</NOBR> most probable address:0xb75b6000, proba&lt;002/100</P>
<P class="p186 ft3"><NOBR>[se
tion:012<SPAN class="ft34">℄ </SPAN>/lib/libnss_
ompat-2.12.1.so</NOBR> most probable address:0xb75b8000, proba&lt;002/100</P>
<P class="p185 ft24"><NOBR>[se
tion:013<SPAN class="ft34">℄ </SPAN>/lib/libnss_
ompat-2.12.1.so</NOBR> most probable address:0xb75b9000, proba&lt;002/100</P>
<P class="p186 ft24"><NOBR>[se
tion:014<SPAN class="ft34">℄ </SPAN>/lib/libnss_
ompat-2.12.1.so</NOBR> most probable address:0xb75ba000, proba&lt;002/100</P>
<P class="p187 ft3"><NOBR>[se
tion:015<SPAN class="ft34">℄ </SPAN>/lib/libnsl-2.12.1.so</NOBR></P>
<P class="p181 ft24">most probable address:0xb7711000, proba&lt;002/100</P>
<P class="p10 ft3"><NOBR>[se
tion:016<SPAN class="ft34">℄ </SPAN>/lib/libnsl-2.12.1.so</NOBR></P>
<P class="p181 ft24">most probable address:0xb7713000, proba&lt;002/100</P>
<P class="p10 ft3"><NOBR>[se
tion:017<SPAN class="ft34">℄ </SPAN>/lib/libnsl-2.12.1.so</NOBR></P>
<P class="p182 ft5">most probable address:0xb7714000, proba&lt;002/100 [se
tion:018<SPAN class="ft34">℄</SPAN></P>
<P class="p183 ft3">most probable address:0xb7718000, proba&lt;002/100</P>
<P class="p185 ft24">[se
tion:019<SPAN class="ft34">℄ </SPAN>/lib/se
urity/pam_rootok.so most probable address:0xb771a000, proba&lt;002/100</P>
<P class="p186 ft24">[se
tion:020<SPAN class="ft34">℄ </SPAN>/lib/se
urity/pam_rootok.so most probable address:0xb771b000, proba&lt;002/100</P>
<P class="p186 ft3">[se
tion:021<SPAN class="ft34">℄ </SPAN>/lib/se
urity/pam_rootok.so most probable address:0xb771
000, proba&lt;002/100</P>
<P class="p10 ft24">[se
tion:022<SPAN class="ft34">℄ </SPAN>/lib/libpam.so.0.82.2</P>
<P class="p181 ft3">most probable address:0xb7727000, proba&lt;002/100</P>
<P class="p10 ft24">[se
tion:023<SPAN class="ft34">℄ </SPAN>/lib/libpam.so.0.82.2</P>
<P class="p181 ft3">most probable address:0xb7728000, proba&lt;002/100</P>
<P class="p10 ft3">[se
tion:024<SPAN class="ft34">℄ </SPAN>/lib/libpam.so.0.82.2</P>
<P class="p181 ft24">most probable address:0xb774f000, proba&lt;002/100</P>
<P class="p185 ft24">[se
tion:025<SPAN class="ft34">℄ </SPAN>/lib/libpam_mis
.so.0.82.0 most probable address:0xb7751000, proba&lt;002/100</P>
<P class="p186 ft3">[se
tion:026<SPAN class="ft34">℄ </SPAN>/lib/libpam_mis
.so.0.82.0 most probable address:0xb7752000, proba&lt;002/100</P>
<P class="p185 ft24">[se
tion:027<SPAN class="ft34">℄ </SPAN>/lib/libpam_mis
.so.0.82.0 most probable address:0xb776e000, proba&lt;002/100</P>
<P class="p187 ft2">[se
tion:028<SPAN class="ft34">℄</SPAN></P>
</DIV>
<DIV id="id19_2">
<P class="p10 ft0">19</P>
</DIV>
</DIV>
<DIV id="page_20">
<DIV id="p20dimg1">
<IMG src="data:image/jpg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAABAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD5/ooooAKKKKACiiigAooooAKKKKAP/9k=" id="p20img1"></DIV>


<DIV id="id20_1">
<P class="p188 ft3">most probable address:0xb776f000, proba&lt;002/100</P>
<P class="p58 ft3"><NOBR>[se
tion:029<SPAN class="ft34">℄ </SPAN>/lib/lib
-2.12.1.so</NOBR></P>
<P class="p188 ft2">most probable address:0xbf7e4000, proba&lt;002/100</P>
<P class="p189 ft4">Computing those probabilities in an e<SPAN class="ft1"></SPAN>e
tive way is in itself quite a 
hallenge : when should one stop the pro
ess and assume it is fully mapped ? The te
hnique should also 
ope with network daemon that bind ports and may pose an additional problem. If we exe
ute say OpenSSH and wait for it to be fully loaded, re
ord its mapping and shut it down, the port 22 will not be available immediately for rebinding.</P>
<P class="p190 ft5">To 
ope with those problems, pm
ma attempts to re
ord mappings right after the proper loading of the main binary and its asso
iated shared libraries. To a
hieve this aim, pm
ma runs the appli
ation while debugging it using the PTRACE_SYSCALL request of ptra
e(). This allows pm
ma to be made aware of any system 
all performed by the debugged pro
ess. It then maintains a list of system 
alls used during the loading of an appli
ation:</P>
<P class="p191 ft23">int allowed_sys
alls[<SPAN class="ft34">℄</SPAN>={3,5,6,11,33,45,91,125,192,197,243}; /*Those sys
alls are used during exe
ve() and loading :</P>
<TABLE cellpadding=0 cellspacing=0 class="t7">
<TR>
	<TD class="tr0 td42"><P class="p12 ft10">read</P></TD>
	<TD class="tr0 td43"><P class="p192 ft10">3</P></TD>
</TR>
<TR>
	<TD class="tr3 td42"><P class="p12 ft10">open</P></TD>
	<TD class="tr3 td43"><P class="p192 ft10">5</P></TD>
</TR>
<TR>
	<TD class="tr4 td42"><P class="p12 ft10">
lose</P></TD>
	<TD class="tr4 td43"><P class="p192 ft10">6</P></TD>
</TR>
<TR>
	<TD class="tr3 td42"><P class="p12 ft10">exe
ve</P></TD>
	<TD class="tr3 td43"><P class="p192 ft10">11</P></TD>
</TR>
<TR>
	<TD class="tr3 td42"><P class="p12 ft10">a

ess</P></TD>
	<TD class="tr3 td43"><P class="p192 ft10">33</P></TD>
</TR>
<TR>
	<TD class="tr4 td42"><P class="p12 ft10">brk</P></TD>
	<TD class="tr4 td43"><P class="p192 ft10">45</P></TD>
</TR>
<TR>
	<TD class="tr3 td42"><P class="p12 ft10">munmap</P></TD>
	<TD class="tr3 td43"><P class="p192 ft10">91</P></TD>
</TR>
<TR>
	<TD class="tr4 td42"><P class="p12 ft10">mprote
t</P></TD>
	<TD class="tr4 td43"><P class="p192 ft10">125</P></TD>
</TR>
<TR>
	<TD class="tr3 td42"><P class="p12 ft10">mmap2</P></TD>
	<TD class="tr3 td43"><P class="p192 ft10">192</P></TD>
</TR>
<TR>
	<TD class="tr3 td42"><P class="p12 ft10">fstat64</P></TD>
	<TD class="tr3 td43"><P class="p192 ft10">197</P></TD>
</TR>
<TR>
	<TD class="tr0 td42"><P class="p12 ft2">set_thread_area</P></TD>
	<TD class="tr0 td43"><P class="p192 ft2">243*/</P></TD>
</TR>
</TABLE>
<P class="p193 ft4">Whenever a system 
all performed by the debugged pro
ess doesn't belong to this white list, pm
ma assumes that exe
ution has already been transfered to the entry point of the appli
ation, and that the loading has therefore entirely been done. It then re
ords the base address of ea
h se
tion of the mapping and kills the debugged pro
ess.</P>
<P class="p190 ft5">The net bene<SPAN class="ft1"></SPAN>t of this te
hnique is to allow for a very e<SPAN class="ft1"></SPAN>e
tive re
ording of mappings. The only map- pings pm
ma would a
tually missed are those performed mu
h later during exe
ution su
h as pluggings or shared libraries mapped by the appli
ation itself.</P>
<P class="p194 ft5">Finally, that the same aim 
an be rea
hed in a simpler way by putting a breakpoint on the entry point of the binary .</P>
<P class="p195 ft2">Thanks to Ivanlef0u for this idea.</P>
</DIV>
<DIV id="id20_2">
<P class="p10 ft0">20</P>
</DIV>
</DIV>
<DIV id="page_21">


<DIV id="id21_1">
<P class="p10 ft2"><SPAN class="ft2">6.2</SPAN><SPAN class="ft30">Non Position Independant Exe
utables</SPAN></P>
<P class="p196 ft3">As mentioned before in this arti
le, binaries not expli
itly 
ompiled as position independent exe
utables do not have their se
tions randomised (only their share libraries if any, their heap and sta
k are).</P>
<P class="p7 ft5">If Linux distributions biased towards se
urity instead of performan
e su
h as Gentoo Hardened with grse
urity kernels enfor
e PIE 
ompilation on every single binary of the system, this is hardly the 
ase for the vast majority of the Linux distributions.</P>
<P class="p87 ft5">Mainstream distributions su
h as Fedora or Ubuntu only impose PIE 
ompilation on a 
arefully 
hosen set of binaries. Typi
ally only network deamons.</P>
<P class="p9 ft5">It means that even setuid binaries su
h as /bin/su or network 
lients su
h as web browsers are not 
ompiled as position independent exe
utables, and have therefore some se
tions not randomized. This may not seem too bad at <SPAN class="ft1"></SPAN>rst sight, but it really means that when looking for a <SPAN class="ft1"></SPAN>x pivoting address inside the appli
ation, an atta
ker is guaranteed to <SPAN class="ft1"></SPAN>nd some. This may be used not only to write 100% reliable ret2plt bootstrap shell
ode in 
ase of sta
k over<SPAN class="ft1"></SPAN>ows, but also sometimes return to the .text of the binary as explained earlier in 
ase of pointer trun
ations. We will see that this weakness 
an also be used to infere the mapping of the whole appli
ation when attempting to leak the layout of the binary towards the end of this 
hapter.</P>
<P class="p197 ft2"><SPAN class="ft2">6.3</SPAN><SPAN class="ft30">Prelinking</SPAN></P>
<P class="p134 ft5">Prelinking is a time saving feature, employed notably by default on Fedora. It allows for faster loading of appli
ations by pre
omputing the lo
ation of the shared libraries inside a pro
ess, and hard
oding those lo
ations on disk.</P>
<P class="p32 ft4">The Fedora prelinking is renewed every two weeks thanks to a 
ron job. It means that during 14 days, the mapping of the shared libraries of a given pro
ess are entirely deterministi
. Under pm
ma, this means that the probability asso
iated with the mappings of a given se
tion fo a shared library will be of 100%.</P>
<P class="p33 ft13">Fedora's do
umentation expli
itly mentioned this behavior[18<SPAN class="ft1">℄ </SPAN>and 
on
ludes that the risk is a

eptable sin
e the mapping of shared library is 
hosen randomly every two weeks. In parti
ular it will di<SPAN class="ft1"></SPAN>er from ma
hine to ma
hine. We will see later in this 
hapter the limits of those assumptions : if an atta
ker 
ould somehow retrieve the mapping of a given pro
ess at a given point in time, he would then know the mapping of subsequent exe
utions of this same binary for some time.</P>
<P class="p179 ft2"><SPAN class="ft2">6.4</SPAN><SPAN class="ft30">Biased ASLR</SPAN></P>
<P class="p198 ft24">Finally, it is worth mentioning that some distributions have very biased ASLR, due to improper kernels. This allows for probabilisti
 exploitation of binaries.</P>
<P class="p187 ft2">Here is an example of an analysis performed by pm
ma on Ubuntu 10.10 with a kernel <NOBR>2.6.32-26-generi
:</NOBR></P>
<P class="p199 ft3"><NOBR>--[</NOBR> Performing ASLR tests:</P>
<P class="p10 ft24">[se
tion:001<SPAN class="ft34">℄ </SPAN>/bin/ping</P>
<P class="p181 ft3">most probable address:0x08048000, proba=100/100</P>
<P class="p10 ft24">[se
tion:002<SPAN class="ft34">℄ </SPAN>/bin/ping</P>
<P class="p181 ft3">most probable address:0x08050000, proba=100/100</P>
<P class="p10 ft3">[se
tion:003<SPAN class="ft34">℄ </SPAN>/bin/ping</P>
<P class="p182 ft5">most probable address:0x08051000, proba=100/100 [se
tion:004<SPAN class="ft34">℄</SPAN></P>
<P class="p183 ft3">most probable address:0x08052000, proba=100/100</P>
<P class="p10 ft24">[se
tion:005<SPAN class="ft34">℄ </SPAN>[heap<SPAN class="ft34">℄</SPAN></P>
<P class="p181 ft2">most probable address:0xb76a7000, proba&lt;003/100</P>
</DIV>
<DIV id="id21_2">
<P class="p10 ft0">21</P>
</DIV>
</DIV>
<DIV id="page_22">


<DIV id="id22_1">
<P class="p200 ft3"><NOBR>[se
tion:006<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/libnss_files-2.10.1.so</NOBR> most probable address:0xb76a9000, proba&lt;003/100</P>
<P class="p200 ft24"><NOBR>[se
tion:007<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/libnss_files-2.10.1.so</NOBR> most probable address:0xb77e7000, proba&lt;003/100</P>
<P class="p201 ft24"><NOBR>[se
tion:008<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/libnss_files-2.10.1.so</NOBR> most probable address:0xb77e8000, proba&lt;003/100</P>
<P class="p202 ft3">[se
tion:009<SPAN class="ft34">℄</SPAN></P>
<P class="p203 ft24">most probable address:0xb77ea000, proba&lt;003/100</P>
<P class="p204 ft24"><NOBR>[se
tion:010<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/lib
-2.10.1.so</NOBR> most probable address:0xb77eb000, proba&lt;013/100</P>
<P class="p205 ft3"><NOBR>[se
tion:011<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/lib
-2.10.1.so</NOBR> most probable address:0xb77ee000, proba&lt;014/100</P>
<P class="p204 ft24"><NOBR>[se
tion:012<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/lib
-2.10.1.so</NOBR> most probable address:0xb77fe000, proba&lt;013/100</P>
<P class="p205 ft24"><NOBR>[se
tion:013<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/lib
-2.10.1.so</NOBR> most probable address:0xb77ff000, proba&lt;013/100</P>
<P class="p202 ft3">[se
tion:014<SPAN class="ft34">℄</SPAN></P>
<P class="p203 ft24">most probable address:0xb7800000, proba&lt;003/100</P>
<P class="p206 ft3"><NOBR>[se
tion:015<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/libresolv-2.10.1.so</NOBR> most probable address:0xb7810000, proba&lt;003/100</P>
<P class="p206 ft24"><NOBR>[se
tion:016<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/libresolv-2.10.1.so</NOBR> most probable address:0xb7812000, proba&lt;003/100</P>
<P class="p207 ft24"><NOBR>[se
tion:017<SPAN class="ft34">℄ </SPAN>/lib/tls/i686/
mov/libresolv-2.10.1.so</NOBR> most probable address:0xb7813000, proba&lt;003/100</P>
<P class="p202 ft3">[se
tion:018<SPAN class="ft34">℄</SPAN></P>
<P class="p208 ft5">most probable address:0xb782e000, proba&lt;003/100 [se
tion:019<SPAN class="ft34">℄</SPAN></P>
<P class="p209 ft24">most probable address:0xb782f000, proba&lt;003/100</P>
<P class="p129 ft3">[se
tion:020<SPAN class="ft34">℄ </SPAN>[vdso<SPAN class="ft34">℄</SPAN></P>
<P class="p203 ft2">most probable address:0xbfa7d000, proba&lt;002/100</P>
<P class="p210 ft10">In this analysis, pm
ma was able to report that some shared libraries su
h as the lib
 a
tually have a</P>
<P class="p211 ft3">given base address for their mapping mu
h more probable (up to 13% of the time) than expe
ted.<A href="#page_22"><SPAN class="ft6">12</SPAN></A>. If upgrading to a more re
ent kernel shipped by Ubuntu <SPAN class="ft1"></SPAN>xes this parti
ular problem, it fundamentally</P>
<P class="p212 ft5">means that 
ustom kernels 
ompiled by system administrators not su<SPAN class="ft1"></SPAN>
iently knowledgeable about se
urity 
an lead to weak ASLR.</P>
<P class="p213 ft0"><SPAN class="ft0">6.5</SPAN><SPAN class="ft21">Memory mapping leakage</SPAN></P>
<P class="p214 ft5">Previous resear
hes[19<SPAN class="ft1">℄</SPAN><A href="#page_31">[20</A><SPAN class="ft1">℄</SPAN>, and in parti
ular the 2010 WTFuzz exploit against IE8 under Windows 7[21<SPAN class="ft1">℄ </SPAN>whi
h won the pwn2own 
ontest have shown that using JavaS
ript and a heap over<SPAN class="ft1"></SPAN>ow to over- write the NULL terminator of a Javas
ript string, it was possible for an atta
ker to be given more information than he should have a

essed (when reading from the string in question). If the leaked bytes (whi
h may be in random quantity, up to the next NULL byte) 
ontained a pointer to data in other se
tions, then the atta
ker 
ould infer the lo
ation of a mapping of a given se
tion inside the running pro
ess (from JavaS
ript itself) and trigger a very pre
ise se
ond write to obtain arbitrary 
ode exe
ution.</P>
<P class="p215 ft5">To further generalise this te
hnique, let's take a step ba
k and look at the problem from a kernel's stand point. Essentially, all the information sent to an atta
ker use only a few system 
alls. Namely sys_write() and sys_so
ketsys
all(). The later o<SPAN class="ft1"></SPAN>ers a few di<SPAN class="ft1"></SPAN>erent requests and now handles what used to be all the other so
ket related system 
alls, su
h as sys_
onne
t(), or sys_send(). Let's have a look at the 
ode of this system 
all in kernel 2.6.39 sour
e 
ode<A href="#page_22"><SPAN class="ft6">13</SPAN></A>:</P>
<P class="p216 ft2"><SPAN class="ft31">12</SPAN><SPAN class="ft37">The analysi</SPAN>s also shows that the 
ode, data and read only data segments of ping are not randomized at all, but this was a
tually expe
ted given that this binary isn't 
ompiled as PIE.</P>
<P class="p10 ft5"><SPAN class="ft8">13</SPAN><SPAN class="ft9">Sample 
ode taken from net/so
ket.
</SPAN></P>
</DIV>
<DIV id="id22_2">
<P class="p10 ft0">22</P>
</DIV>
</DIV>
<DIV id="page_23">


<DIV id="id23_1">
<TABLE cellpadding=0 cellspacing=0 class="t8">
<TR>
	<TD class="tr0 td44"><P class="p12 ft10">2234</P></TD>
	<TD class="tr0 td45"><P class="p160 ft10">SYSCALL_DEFINE2(so
ket
all, int, 
all, unsigned long __user *, args)</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2235</P></TD>
	<TD class="tr3 td45"><P class="p160 ft10">{</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2236</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">unsigned long a[6<SPAN class="ft34">℄</SPAN>;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2237</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">unsigned long a0, a1;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2238</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">int err;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2239</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">unsigned int len;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2240</P></TD>
	<TD class="tr3 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">...</P></TD>
	<TD class="tr3 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2247</P></TD>
	<TD class="tr4 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2248</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">/* 
opy_from_user should be SMP safe. */</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2249</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">if (
opy_from_user(a, args, len))</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2250</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">return <NOBR>-EFAULT;</NOBR></P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2251</P></TD>
	<TD class="tr3 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2252</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">audit_so
ket
all(nargs[
all<SPAN class="ft34">℄ </SPAN>/ sizeof(unsigned long), a);</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2253</P></TD>
	<TD class="tr3 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2254</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">a0 = a[0<SPAN class="ft34">℄</SPAN>;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2255</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">a1 = a[1<SPAN class="ft34">℄</SPAN>;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2256</P></TD>
	<TD class="tr3 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2257</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">swit
h (
all) {</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2258</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">
ase SYS_SOCKET:</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2259</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">err = sys_so
ket(a0, a1, a[2<SPAN class="ft34">℄</SPAN>);</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2260</P></TD>
	<TD class="tr4 td45"><P class="p217 ft10">break;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2261</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">
ase SYS_BIND:</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2262</P></TD>
	<TD class="tr4 td45"><P class="p217 ft10">err = sys_bind(a0, (stru
t so
kaddr __user *)a1, a[2<SPAN class="ft34">℄</SPAN>);</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2263</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">break;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2264</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">
ase SYS_CONNECT:</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2265</P></TD>
	<TD class="tr4 td45"><P class="p217 ft10">err = sys_
onne
t(a0, (stru
t so
kaddr __user *)a1, a[2<SPAN class="ft34">℄</SPAN>);</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2266</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">break;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2267</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">
ase SYS_LISTEN:</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2268</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">err = sys_listen(a0, a1);</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2269</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">break;</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2270</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">
ase SYS_ACCEPT:</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2271</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">err = sys_a

ept4(a0, (stru
t so
kaddr __user *)a1,</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2272</P></TD>
	<TD class="tr4 td45"><P class="p218 ft10">(int __user *)a[2<SPAN class="ft34">℄</SPAN>, 0);</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">...</P></TD>
	<TD class="tr3 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2287</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">
ase SYS_SEND:</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2288</P></TD>
	<TD class="tr4 td45"><P class="p217 ft10">err = sys_send(a0, (void __user *)a1, a[2<SPAN class="ft34">℄</SPAN>, a[3<SPAN class="ft34">℄</SPAN>);</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2289</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">break;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2290</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">
ase SYS_SENDTO:</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2291</P></TD>
	<TD class="tr4 td45"><P class="p217 ft10">err = sys_sendto(a0, (void __user *)a1, a[2<SPAN class="ft34">℄</SPAN>, a[3<SPAN class="ft34">℄</SPAN>,</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2292</P></TD>
	<TD class="tr3 td45"><P class="p219 ft10">(stru
t so
kaddr __user *)a[4<SPAN class="ft34">℄</SPAN>, a[5<SPAN class="ft34">℄</SPAN>);</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">...</P></TD>
	<TD class="tr4 td45"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2327</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">default:</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2328</P></TD>
	<TD class="tr3 td45"><P class="p217 ft10">err = <NOBR>-EINVAL;</NOBR></P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2329</P></TD>
	<TD class="tr4 td45"><P class="p217 ft10">break;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">2330</P></TD>
	<TD class="tr3 td45"><P class="p192 ft10">}</P></TD>
</TR>
<TR>
	<TD class="tr4 td44"><P class="p12 ft10">2331</P></TD>
	<TD class="tr4 td45"><P class="p192 ft10">return err;</P></TD>
</TR>
<TR>
	<TD class="tr0 td44"><P class="p12 ft2">2332</P></TD>
	<TD class="tr0 td45"><P class="p160 ft2">}</P></TD>
</TR>
</TABLE>
</DIV>
<DIV id="id23_2">
<P class="p10 ft0">23</P>
</DIV>
</DIV>
<DIV id="page_24">


<DIV id="id24_1">
<P class="p30 ft23">In a nutshell, to 
all sys_so
ket
all, eax has to worth 102, then ebx spe
i<SPAN class="ft1"></SPAN>es whi
h parti
ular 
all is to be performed, a

ording to the following requests, de<SPAN class="ft1"></SPAN>ned in in
lude/linux/net.h:</P>
<TABLE cellpadding=0 cellspacing=0 class="t9">
<TR>
	<TD class="tr0 td46"><P class="p97 ft10">26</P></TD>
	<TD class="tr0 td47"><P class="p131 ft10">#define SYS_SOCKET</P></TD>
	<TD class="tr0 td48"><P class="p131 ft10">1</P></TD>
	<TD class="tr0 td49"><P class="p220 ft10">/* sys_so
ket(2)</P></TD>
	<TD class="tr0 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">27</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_BIND</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">2</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_bind(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr4 td46"><P class="p97 ft10">28</P></TD>
	<TD class="tr4 td47"><P class="p131 ft10">#define SYS_CONNECT</P></TD>
	<TD class="tr4 td48"><P class="p131 ft10">3</P></TD>
	<TD class="tr4 td49"><P class="p220 ft10">/* sys_
onne
t(2)</P></TD>
	<TD class="tr4 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">29</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_LISTEN</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">4</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_listen(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr4 td46"><P class="p97 ft10">30</P></TD>
	<TD class="tr4 td47"><P class="p131 ft10">#define SYS_ACCEPT</P></TD>
	<TD class="tr4 td48"><P class="p131 ft10">5</P></TD>
	<TD class="tr4 td49"><P class="p220 ft10">/* sys_a

ept(2)</P></TD>
	<TD class="tr4 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">31</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_GETSOCKNAME</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">6</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_getso
kname(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">32</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_GETPEERNAME</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">7</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_getpeername(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr4 td46"><P class="p97 ft10">33</P></TD>
	<TD class="tr4 td47"><P class="p131 ft10">#define SYS_SOCKETPAIR</P></TD>
	<TD class="tr4 td48"><P class="p131 ft10">8</P></TD>
	<TD class="tr4 td49"><P class="p220 ft10">/* sys_so
ketpair(2)</P></TD>
	<TD class="tr4 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">34</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_SEND</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">9</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_send(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr4 td46"><P class="p97 ft10">35</P></TD>
	<TD class="tr4 td47"><P class="p131 ft10">#define SYS_RECV</P></TD>
	<TD class="tr4 td48"><P class="p131 ft10">10</P></TD>
	<TD class="tr4 td49"><P class="p220 ft10">/* sys_re
v(2)</P></TD>
	<TD class="tr4 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">36</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_SENDTO</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">11</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_sendto(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">37</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_RECVFROM</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">12</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_re
vfrom(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr4 td46"><P class="p97 ft10">38</P></TD>
	<TD class="tr4 td47"><P class="p131 ft10">#define SYS_SHUTDOWN</P></TD>
	<TD class="tr4 td48"><P class="p131 ft10">13</P></TD>
	<TD class="tr4 td49"><P class="p220 ft10">/* sys_shutdown(2)</P></TD>
	<TD class="tr4 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">39</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_SETSOCKOPT</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">14</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_setso
kopt(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr4 td46"><P class="p97 ft10">40</P></TD>
	<TD class="tr4 td47"><P class="p131 ft10">#define SYS_GETSOCKOPT</P></TD>
	<TD class="tr4 td48"><P class="p131 ft10">15</P></TD>
	<TD class="tr4 td49"><P class="p220 ft10">/* sys_getso
kopt(2)</P></TD>
	<TD class="tr4 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">41</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_SENDMSG</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">16</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_sendmsg(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr3 td46"><P class="p97 ft10">42</P></TD>
	<TD class="tr3 td47"><P class="p131 ft10">#define SYS_RECVMSG</P></TD>
	<TD class="tr3 td48"><P class="p131 ft10">17</P></TD>
	<TD class="tr3 td49"><P class="p220 ft10">/* sys_re
vmsg(2)</P></TD>
	<TD class="tr3 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr4 td46"><P class="p97 ft10">43</P></TD>
	<TD class="tr4 td47"><P class="p131 ft10">#define SYS_ACCEPT4</P></TD>
	<TD class="tr4 td48"><P class="p131 ft10">18</P></TD>
	<TD class="tr4 td49"><P class="p220 ft10">/* sys_a

ept4(2)</P></TD>
	<TD class="tr4 td14"><P class="p14 ft10">*/</P></TD>
</TR>
<TR>
	<TD class="tr0 td46"><P class="p97 ft2">44</P></TD>
	<TD class="tr0 td47"><P class="p131 ft2">#define SYS_RECVMMSG</P></TD>
	<TD class="tr0 td48"><P class="p131 ft2">19</P></TD>
	<TD class="tr0 td49"><P class="p220 ft2">/* sys_re
vmmsg(2)</P></TD>
	<TD class="tr0 td14"><P class="p14 ft2">*/</P></TD>
</TR>
</TABLE>
<P class="p221 ft4">So, to monitor all the data leaving the pro
ess and possibly rea
hing an atta
ker, being it over so
kets, <SPAN class="ft1"></SPAN>les, ttys or any other mean, all we need to pay attention to is sys_write() (sys
all 4 under Intel x86 ar
hite
tures), and sys_so
ket
all() (sys
all 102 under Intel x86 ar
hite
tures) for a few 
arefully 
hosen <NOBR>sub-
alls:</NOBR> sys_send(), sys_sendto(), sys_sendmsg().</P>
<P class="p7 ft5">The main idea is to pro
eed as following: <SPAN class="ft1"></SPAN>rst of, make the original pro
ess fork() on
e. Unlike with previous te
hniques, we then let the original pro
ess run, and monitor it using the ptra
e() PTRACE_SYSCALL request, whi
h allows us to break every time the pro
ess will perform a sys- tem 
all. We re
ord all the system 
alls exe
uted, as well as their return data and values. We now have a referen
e run to 
ompare subsequent experiments with.</P>
<P class="p85 ft19">Then, we make the saved o<SPAN class="ft1"></SPAN>spring and make it fork(). We overwrite the <SPAN class="ft1"></SPAN>rst writable lo
ation in mem- ory with dummy data. We then tra
e its exe
ution thanks to the same ptra
e() PTRACE_SYSCALL request. Everytime this pro
essattempts to exe
ute a system 
all, we 
ompare it's input registers with the one of the original pro
ess. If the sys
all to be exe
uted is either sys_write(), or sys_so
ket
all() with a relevant <NOBR>sub-
all,</NOBR> we verify if the data to be pro
essed di<SPAN class="ft1"></SPAN>ers from the one of the original pro
ess.</P>
<P class="p180 ft4">Three 
ases may arise : the amount of data sent may di<SPAN class="ft1"></SPAN>er. If it is now larger, we have found a lo
ation in memory, whi
h, when overwritten, for
es the appli
ation to send more data than expe
ted ba
k to the atta
ker. This would be the 
ase when overwritting for instan
e a variable stored in a read/write se
tion, and used as the length argument in the following statement:</P>
<P class="p222 ft2">write(3,&buff,length);</P>
<P class="p223 ft5">The se
ond 
ase happens when the data is entirely di<SPAN class="ft1"></SPAN>erent, be
ause for instan
e we would have overwritten a pointer to the bu<SPAN class="ft1"> </SPAN>variable in the previous 
ase.</P>
<P class="p224 ft5">The third 
ase is when both the data and the length di<SPAN class="ft1"></SPAN>er entirely, for instan
e when overwritting a pointer to bu<SPAN class="ft1"> </SPAN>and then 
alling the pointer to data and then 
alling the following system 
all via sys_so
ket
all():</P>
<P class="p138 ft2">sendto(so
kfd,&buff,sizeof(buff),0);</P>
</DIV>
<DIV id="id24_2">
<P class="p10 ft0">24</P>
</DIV>
</DIV>
<DIV id="page_25">


<DIV id="id25_1">
<P class="p225 ft5">In all of those 
ases, we 
an a
tually with a pretty high a

ura
y verify if an interresting memory leak o

ured, whi
h will allow an atta
ker to dedu
e the mappings of the binary. For this 
ondition to o

ur, the leaked data (either new trailing bytes, or entirely di<SPAN class="ft1"></SPAN>erent data sent ba
k to the atta
ker) needs to 
ontain a pointer to any se
tion in the binary. Be
ause of the way ASLR is performed under Linux (all the se
tions but heap and sta
k being translated by a 
onstant o<SPAN class="ft1"></SPAN>set), knowing a single pointer to the main binary or to a shared library will result in knowledge of the almost whole mapping. To dis
over the lo
ation of the heap or sta
k, we would need in addition to <SPAN class="ft1"></SPAN>nd a pointer to the heap (possible) and the sta
k (less realisti
) in the data sent to the atta
ker. This is really only a matter of parsing the new data sent by the pro
ess, and mat
h potential pointers against the memory addresses of ea
h se
tion in its address spa
e.</P>
<P class="p226 ft5">We mentioned earlier that one of the biggest limitation of pm
ma is the fa
t that system 
alls performed by o<SPAN class="ft1"></SPAN>springs 
ould provide a di<SPAN class="ft1"></SPAN>erent result than in the original pro
ess provided the same inputs (be
ause so
kets will now be 
losed, <SPAN class="ft1"></SPAN>le des
riptors in unde<SPAN class="ft1"></SPAN>ned states...). Sin
e we have now des
ribed a method to re
ord the system 
alls performed by the original pro
ess, it is possible to fake them in the o<SPAN class="ft1"></SPAN>springs (by using the ptra
e() PTRACE_SYSCALL until a system 
all is to be 
alled, and modify the ouput registers and optionally their asso
iated data before adjusting eip : we don't even need to a
tually perform a real system 
all). The main in
onvenient of this te
hnique is the fa
t that some system 
alls pass data in non standard ways (eg: sys_so
ket
all()). We 
ould extend pm
ma to know how ea
h sys
all expe
ts and modi<SPAN class="ft1"></SPAN>es data, but there are about 300 of them in a modern Linux kernel, and they are ar
hite
ture spe
i<SPAN class="ft1"></SPAN>
. Also, using PTRACE_SYSCALL has a non negligeable overhead in terms of performan
e.</P>
</DIV>
<DIV id="id25_2">
<P class="p10 ft0">25</P>
</DIV>
</DIV>
<DIV id="page_26">


<DIV id="id26_1">
<P class="p10 ft2"><SPAN class="ft2">7</SPAN><SPAN class="ft12">Extending the 
apabilities of pm
ma</SPAN></P>
<P class="p224 ft4">We have so far fo
used on exploitation of invalid memory writes through the use of fun
tion pointer. Pm
ma is 
apable of mu
h more, and the 
apabilities o<SPAN class="ft1"></SPAN>ered in terms of exploitation modeling by the mk_fork() te
hnique haven't been fully explored yet. In this 
hapter, we will des
ribe a few distin
tive features of pm
ma.</P>
<P class="p81 ft2"><SPAN class="ft2">7.1</SPAN><SPAN class="ft30">Call tables and returns to registers+o</SPAN><SPAN class="ft1"></SPAN>sets</P>
<P class="p224 ft5">Pure fun
tion pointers are not the only way to dire
tly modify the <SPAN class="ft1"></SPAN>ow of exe
ution of an appli
ation given an arbitary write bug. For exemple, redire
tion of the 
ontrol <SPAN class="ft1"></SPAN>ow via 
all tables and dire
t modi<SPAN class="ft1"></SPAN>
ations of the 
ontrol <SPAN class="ft1"></SPAN>ow based on the value of a register, su
h as jmp [eax+0xdeadbeef<SPAN class="ft1">℄ </SPAN>or 
all [ebx+0x
0f33babe<SPAN class="ft1">℄ </SPAN>
ould be in<SPAN class="ft1"></SPAN>uen
ed in 
ase an atta
ker 
ould perform a 
ontrolled write when exploiting an invalid write vulnerability.</P>
<P class="p135 ft5">Pm
ma is also able to dete
t the o

urren
e of su
h s
enarios when attempting to write to di<SPAN class="ft1"></SPAN>erent lo
ations in the writable se
tions of an appli
ation. When reporting 
ontrol <SPAN class="ft1"></SPAN>ow modi<SPAN class="ft1"></SPAN>
ations, it will di<SPAN class="ft1"></SPAN>erentiate the 
ase where the value it has written to memory is the exa
t address later being dereferen
ed (labeled as "dire
t 
ontrol <SPAN class="ft1"></SPAN>ow hija
k"). and the 
ase where the it di<SPAN class="ft1"></SPAN>ers ("indire
t 
ontrol <SPAN class="ft1"></SPAN>ow bug"):</P>
<P class="p174 ft3">...</P>
<P class="p178 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xb73
e08
 (full 
ontrol flow hija
k) 0xb73
e08
 <NOBR>--&gt;</NOBR> 0xb734e54e // repeatability:2/100</P>
<P class="p227 ft5">&lt;*&gt; Dereferen
ed fun
tion ptr at 0xb73de0a4 (full 
ontrol flow hija
k) 0xb73de0a4 <NOBR>--&gt;</NOBR> 0xb73d19aa // repeatability:2/100</P>
<P class="p228 ft5"><NOBR>&lt;-&gt;</NOBR> Triggered an indire
t 
ontrol flow bug when writing at 0xb73df000 (ret value=0xf1f3
38
 is unmapped)</P>
<P class="p229 ft2">0xb73df000 <NOBR>--&gt;</NOBR> 0xb73bf000 // repeatability:2/100</P>
<P class="p230 ft5"><NOBR>&lt;-&gt;</NOBR> Triggered an indire
t 
ontrol flow bug when writing at 0xb73df2b0 (ret value=0xf1f8ef7
 is unmapped)</P>
<P class="p229 ft3">0xb73df2b0 <NOBR>--&gt;</NOBR> 0xb7348000 // repeatability:2/100</P>
<P class="p10 ft3">...</P>
<P class="p165 ft24"><NOBR>--&gt;</NOBR> total : 186 validated fun
tion pointers</P>
<P class="p231 ft2">(and found 8 additional 
ontrol flow errors)</P>
<P class="p98 ft4">In the previous example, the addresses where exe
ution was attempted by the appli
ation (0xf1f3
38
 and 0xf1f8ef7
) be
ause of an indire
t 
ontrol <SPAN class="ft1"></SPAN>ow bug are very 
lose to the remarkable test value used (0xf1f2f3f4), whi
h is a string indi
ator that the appli
ation in fa
t added an o<SPAN class="ft1"></SPAN>set to this base value inside a register before attempting to jump (or 
all) the 
orresponding address.</P>
<P class="p81 ft2"><SPAN class="ft2">7.2</SPAN><SPAN class="ft30">Sear
hing for pointers to stru
tures (
ontaining fun
tion pointers)</SPAN></P>
<P class="p232 ft4">Sin
e all se
tions do not always share the same amount of entropy, in parti
ular when biased ASLR has been dete
ted, it is tempting to atta
k the worst prote
ted se
tions <SPAN class="ft1"></SPAN>rst. In 
ase fun
tion pointers were found only in the best randomized se
tions, pm
ma is able to perform yet an other analysis in order to maximize the e<SPAN class="ft1"></SPAN>e
tiveness of exploitation.</P>
<P class="p33 ft23">Instead of atta
king fun
tion pointers dire
tly, it may be worth sear
hing for pointers to data stru
tures in other se
tions (the more heavily randomized ones) 
ontaining fun
tion pointers.</P>
</DIV>
<DIV id="id26_2">
<P class="p10 ft0">26</P>
</DIV>
</DIV>
<DIV id="page_27">


<DIV id="id27_1">
<P class="p30 ft4">The atta
k s
enario would then be the following : instead of overwriting a fun
tion pointer dire
tly, overwrite the pointer (whose address is less randomized) to the stru
ture to point to a user 
ontroled, writable lo
ation. Then fake the stru
ture in this lo
ation, and eventually dereferen
e the fun
tion pointer.</P>
<P class="p33 ft20">The 
onditions for this atta
k to work are quite realisti
 in many 
ases. For instan
e, data stru
tures 
ontaining fun
tion pointers 
reated by the appli
ation itself are typi
ally stored on the heap, whi
h is always heavily randomized, and not a good target for a blind overwrite in terms of probability. But if those fun
tion pointers are in fa
t stored in a linked list, that the <SPAN class="ft1"></SPAN>rst pointer of the liked list is stored on the proper data se
tion of the appli
ation, and that the lo
ation of this <SPAN class="ft1"></SPAN>rst pointer 
an be guessed (for example be
ause the binary isn't PIE), then overwriting the <SPAN class="ft1"></SPAN>rst pointer to point into a user 
ontrolled bu<SPAN class="ft1"></SPAN>er in the data se
tion itself would do the tri
k.</P>
<P class="p86 ft5">In order to dete
t pointers to stru
tures 
ontaining fun
tion pointers, pm
ma <SPAN class="ft1"></SPAN>rst parses the writable se
tions of the binary and sear
h for possible pointers to other writable se
tions. Those will be the 
andidate pointers.</P>
<P class="p6 ft5">Then, it 
reates a new mapping inside o<SPAN class="ft1"></SPAN>springs 
reated by mk_fork(). Those mapping should never be read or written to under normal 
onditions sin
e they have been arti<SPAN class="ft1"></SPAN>
ially 
reated. Then pm
ma modi<SPAN class="ft1"></SPAN>es one pointer 
andidate per o<SPAN class="ft1"></SPAN>spring to point to the beginning of the new mapping.</P>
<P class="p8 ft3">In 
ase this modi<SPAN class="ft1"></SPAN>
ation triggers an invalid memory a

ess in exe
ution, pm
ma dedu
es it has in fa
t overwriten a pointer to a stru
ture 
ontaining a pointer a
tually dereferen
ed.</P>
<P class="p33 ft23">The 
reated mappings also 
ontain a parti
ular pattern of bytes, whi
h helps in identifying at whi
h o<SPAN class="ft1"></SPAN>set inside the mapping a fun
tion pointer is being dereferen
ed.</P>
<P class="p34 ft19">The algorithm to 
reate a new mapping inside an o<SPAN class="ft1"></SPAN>spring relies on the inje
tion of a small stub shell
ode to allo
ate memory via mmap(). The main idea of inje
ting a shell
ode in a debugged pro
ess should be pretty familiar to the reader by now. The 
reation of the mapping then only requires to read the return address of mmap(), whi
h is indeed stored into eax.</P>
<P class="p187 ft2">The shell
ode used to a
hieve a proper memory allo
ation is given below:</P>
<P class="p233 ft24">;</P>
<P class="p10 ft3"><SPAN class="ft3">;</SPAN><SPAN class="ft25">old_mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, 0, 0) shell
ode:</SPAN></P>
<P class="p199 ft3">_start:</P>
<P class="p234 ft3">nop nop nop nop</P>
<P class="p235 ft5">xor eax, eax xor ebx, ebx xor e
x, e
x xor edx, edx xor esi, esi xor edi, edi</P>
<TABLE cellpadding=0 cellspacing=0 class="t10">
<TR>
	<TD class="tr0 td50"><P class="p12 ft10">mov bx,</P></TD>
	<TD class="tr0 td37"><P class="p12 ft10">0x1000</P></TD>
	<TD colspan=2 class="tr0 td51"><P class="p236 ft10">; 1 page</P></TD>
</TR>
<TR>
	<TD class="tr3 td50"><P class="p12 ft10">mov 
l,</P></TD>
	<TD class="tr3 td37"><P class="p12 ft10">0x3</P></TD>
	<TD class="tr3 td52"><P class="p236 ft10">;</P></TD>
	<TD class="tr3 td53"><P class="p131 ft10">PROT_READ|PROT_WRITE</P></TD>
</TR>
<TR>
	<TD class="tr0 td50"><P class="p12 ft2">mov dl,</P></TD>
	<TD class="tr0 td37"><P class="p12 ft2">0x21</P></TD>
	<TD class="tr0 td52"><P class="p236 ft2">;</P></TD>
	<TD class="tr0 td53"><P class="p131 ft2">MAP_SHARED|MAP_ANON</P></TD>
</TR>
</TABLE>
<P class="p237 ft3">push eax push eax</P>
</DIV>
<DIV id="id27_2">
<P class="p10 ft0">27</P>
</DIV>
</DIV>
<DIV id="page_28">


<DIV id="id28_1">
<P class="p238 ft4">push edx push e
x push ebx push eax</P>
<TABLE cellpadding=0 cellspacing=0 class="t11">
<TR>
	<TD colspan=2 class="tr0 td42"><P class="p12 ft10">mov ebx, esp</P></TD>
	<TD class="tr0 td54"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
<TR>
	<TD class="tr3 td44"><P class="p12 ft10">mov</P></TD>
	<TD class="tr3 td24"><P class="p12 ft10">al, 0x5a</P></TD>
	<TD class="tr3 td54"><P class="p12 ft10">; sys_mmap</P></TD>
</TR>
<TR>
	<TD class="tr0 td44"><P class="p12 ft2">int</P></TD>
	<TD class="tr0 td24"><P class="p12 ft2">0x80</P></TD>
	<TD class="tr0 td54"><P class="p12 ft11">&nbsp;</P></TD>
</TR>
</TABLE>
<P class="p239 ft5"><SPAN class="ft5">;</SPAN><SPAN class="ft38">eax 
ontains address of new mapping db 0x

, 0x

, 0x

, 0x

</SPAN></P>
<P class="p195 ft2">A typi
al analysis by pm
ma would then look like:</P>
<P class="p179 ft2"><NOBR>--[</NOBR> Sear
hing pointers to datastru
tures with fun
tion pointers</P>
<P class="p240 ft2">** Pointers to +W se
tions: 15928</P>
<P class="p241 ft5">&lt;*&gt; Dereferen
ed a fun
tion pointer inside a stru
ture when writing at 0x094568e4 (ret value=0xffffffff) // repeatability:1/100</P>
<P class="p242 ft5">&lt;*&gt; Dereferen
ed a fun
tion pointer inside a stru
ture when writing at 0x094616f
 (ret value=0xffffffff) // repeatability:1/100</P>
<P class="p242 ft5">&lt;*&gt; Dereferen
ed a fun
tion pointer inside a stru
ture when writing at 0x094a
960 (ret value=0xffffffff) // repeatability:1/100</P>
<P class="p242 ft5">&lt;*&gt; Dereferen
ed a fun
tion pointer inside a stru
ture when writing at 0x094a
a10 (ret value=0xffffffff) // repeatability:1/100</P>
<P class="p243 ft5">&lt;*&gt; Dereferen
ed a fun
tion pointer inside a stru
ture when writing at 0x094a
ab8 (ret value=0xffffffff) // repeatability:1/100</P>
<P class="p242 ft5">&lt;*&gt; Dereferen
ed a fun
tion pointer inside a stru
ture when writing at 0xbfb81098 (ret value=0xffffffff) // repeatability:0/100</P>
<P class="p244 ft2"><NOBR>--&gt;</NOBR> total : 6 fun
tion pointers identified inside stru
tures</P>
<P class="p173 ft5">In this example, the return value is 0x<SPAN class="ft1"></SPAN>, whi
h 
orresponds to the padding of our newly 
reated mapping. It is therefore not possible to immediately dedu
e from the mapping pattern at whi
h o<SPAN class="ft1"></SPAN>set inside this new mapping, the fun
tion pointer was lo
ated.</P>
<P class="p197 ft0"><SPAN class="ft0">7.3</SPAN><SPAN class="ft21">Testing exhaustively arbitrary writes</SPAN></P>
<P class="p224 ft20">Sin
e pm
ma has the 
apabilities to make the debugged pro
ess fork() at will, it 
an exhaustively attempt to overwrite all the writable addresses mapped inside a given pro
ess, in the hope to trigger invalid memory a

ess in exe
ution mode. This pro
ess is not only slow and resour
e 
onsuming, but pm
ma 
annot attempt to overwrite all those lo
ations with all of the more than 4 billion possible values a 32b register allows. In 
onsequen
e, this option is kept as a last resort in 
ase all of the other strategies failed. It is nonetheless pra
ti
al to overwrite all the possible lo
ations inside a given pro
ess with a prede<SPAN class="ft1"></SPAN>ned remarkable value.</P>
</DIV>
<DIV id="id28_2">
<P class="p10 ft0">28</P>
</DIV>
</DIV>
<DIV id="page_29">


<DIV id="id29_1">
<P class="p127 ft5">This feature may seem ane
dotal at <SPAN class="ft1"></SPAN>rst sight. But it is 
urrently the only way for pm
ma to <SPAN class="ft1"></SPAN>nd the pointers asso
iated with unresolved pro
edure relo
ations. The alternative would be to run all audits with an LD_BINDNOW environment variable set in order to for
e resolution by the dynami
 linker at load time. Unfortunately, this isn't pra
ti
al for analysis of network daemon, at least not without restarting them. In addition, the use of LD_BINDNOW would indu
e modi<SPAN class="ft1"></SPAN>
ations inside the writable mappings of the binary and would no longer re<SPAN class="ft1"></SPAN>e
t its a
tual state in real exploitation 
onditions.</P>
<P class="p245 ft0"><SPAN class="ft0">7.4</SPAN><SPAN class="ft21">Testing invalid reads</SPAN></P>
<P class="p246 ft20">Invalid reads by themselves do not allow dire
t modi<SPAN class="ft1"></SPAN>
ation of the 
ontrol <SPAN class="ft1"></SPAN>ow. They 
an nonetheless be interesting, depending on how this parti
ular memory read is handled inside the appli
ation. If the value read by the faulting instru
tion is user 
ontrolled (meaning : the appli
ation 
an be for
ed to read from a given address in memory whi
h is user 
ontrolled), it may trigger indire
t invalid memory a

esses either in exe
ution or write modes. A trivial example would be an appli
ation using the value just read as a 
ounter in e
x to perform a memory 
opy. By setting this register to a very large value, an atta
ker would indire
tly 
ause an invalid memory a

ess in this loop.</P>
<P class="p247 ft5">Testing for su
h indire
t problems 
aused by an invalid read is fairly straight forward : by setting the register in whi
h the value is read to multiple values in di<SPAN class="ft1"></SPAN>erent o<SPAN class="ft1"></SPAN>springs of the debugged pro
ess, it is possible to dete
t if they would eventually result in an invalid memory a

ess more interesting (either in write or exe
ution mode) later one, simply by ptra
ing the o<SPAN class="ft1"></SPAN>spring and disassembling the faulting address in 
ase a Segmentation Fault was dete
ted.</P>
<P class="p248 ft20">There again, testing the 2<SPAN class="ft0">￿ˆ</SPAN>32 possible values o<SPAN class="ft1"></SPAN>ered by modest 32b pro
essors is most probably a bit overkill. Testing on a thousand of evenly spa
ed values a
ross the sear
h spa
e is mu
h more time saving and would spot most indire
t vulnerabilities anyways.</P>
<P class="p249 ft2"><SPAN class="ft2">8</SPAN><SPAN class="ft12">Sta
k desyn
hronization</SPAN></P>
<P class="p250 ft5">For the most part, we have fo
used so far on where to write in memory in order to a
hieve a modi<SPAN class="ft1"></SPAN>
a- tion of the 
ontrol <SPAN class="ft1"></SPAN>ow. It is about time we also 
onsider the question of what to write. In other word, to 
onsider what an hija
ked fun
tion pointer should be modi<SPAN class="ft1"></SPAN>ed to point to.</P>
<P class="p250 ft4">In 
ase writable se
tions are found to be exe
utable, and at least one is both reasonably 
ontrolled and not too randomized, the answer is quite simple : 
opying a nop sled and shell
ode in at this position would grant an atta
ker arbitrary 
ode exe
ution. This is how exploitation has been a
hieve for about 15 years.</P>
<P class="p251 ft4">But this s
enario is be
oming less and less likely, in parti
ular be
ause writable se
tions are not exe- 
utable anymore thanks either to PaX or 
pu <NOBR>NX-like</NOBR> bits. In parti
ular, the heap, whi
h is the only se
tion that 
an be made almost arbitrary big (whi
h would help in making the exploit probabilisti
ally better thanks to a 
lassi
 heap spray) is not 
ommonly exe
utable anymore under GNU/Linux.</P>
<P class="p252 ft5">In order to over
ome those problems, we suggest to return, not to a writable se
tion, but to a 
arefully 
hosen fun
tion prologue. This indeed requires that su
h a prologue is either available in a non ran- domized se
tion (.text of the binary if 
ompiled without PIE<A href="#page_29"><SPAN class="ft6">14</SPAN></A>), or at an address we 
an predi
t (for instan
e thanks to a memory leak indu
ed by a previous memory write, like explained earlier in this paper).</P>
<P class="p247 ft4">By returning to a 
hosen fun
tion prologue, an atta
ker will get to 
hose by how mu
h he will modi<SPAN class="ft1"></SPAN>ed the sta
k pointer. If they 
ontrol a large bu<SPAN class="ft1"></SPAN>er in the sta
k and 
an 
reate fake sta
k frames in it, then he 
an default ba
k to more standard <NOBR>sta
k-smashing-like</NOBR> exploitation (ret2lib
, ret2plt or ROP depending on randomization and 
ompilation options).</P>
<P class="p253 ft2">To the best of our knowledge, this methodology has never been publi
ly dis
ussed.</P>
<P class="p254 ft5"><SPAN class="ft31">14</SPAN><SPAN class="ft32">We saw ear</SPAN>lier PIE doesn't apply to non network daemons on most distributions yet, for performan
e reasons</P>
</DIV>
<DIV id="id29_2">
<P class="p10 ft0">29</P>
</DIV>
</DIV>
<DIV id="page_30">


<DIV id="id30_1">
<P class="p10 ft2"><SPAN class="ft2">9</SPAN><SPAN class="ft12">Performan
e 
onsiderations</SPAN></P>
<P class="p86 ft5">Pm
ma starts its analysis by dumping to disk all the mapped se
tion of the analysed binary for easier study. This preliminary phase is parti
ularly 
ostly.</P>
<P class="p7 ft4">The other phase whi
h is really 
ostly in terms of performan
e is parsing all se
tions mapped as writable, list their potential pointers to other se
tions, and verify if they point to valid assembly instru
tions by disassembling the destination bytes. The 
ost of this phase is O(n), where n is the size of writable memory inside the pro
ess.</P>
<P class="p7 ft5">Finally, for ea
h potential fun
tion pointer dis
overed, pm
ma will 
reate a new pro
ess, overwrite the test pointer with a known value and run the pro
ess. This phase is in O(p), where p is the number of potential fun
tion pointers dis
overed.</P>
<P class="p87 ft5">Experimentally when looking for fun
tion pointers, an analysis performed by pm
ma ranges from a few se
onds when analysing /bin/ping to about one hour when analysing the Opera web browser when 
rashing after performing a 
ertain amount of heap sparying (resulting in a total of 1.3Gb or memory mapped, among whi
h more than 1.2Gb is writable memory). The average analysis is of several minutes for most network daemons.</P>
<P class="p255 ft5">It is worth noting that 
urrently, the tests on o<SPAN class="ft1"></SPAN>springs are run sequentially one after the other. But in fa
t, this is not ne
essary, wether sys
all faking is in use or not. In the near future, we hope to modify pm
ma to run those tests in parallel instead of running them sequentially.</P>
<P class="p179 ft2">10 Con
lusion</P>
<P class="p9 ft5">We have brie<SPAN class="ft1"></SPAN>y presented in this arti
le new exploitation te
hniques, or sometimes extension of existing ones, and detailed how they 
ould be tested automati
ally against a target binary vulnerable to invalid memory a

esses.</P>
<P class="p87 ft5">We have exposed how to 
reate exploitation models thanks to a new debugging te
hnique post memory 
orruption, in order to automati
ally study the exploity of sub 
lasses of the invalid memory write bug 
lass.</P>
<P class="p32 ft20">Our proof of 
on
ept tool, pm
ma, doesn't write exploits itself. Instead, its goal is to analyze all the en- vironment 
onstraints of a given system and provide its user with the best possible atta
k methodology for a given vulnerability, generalizing many atta
k ve
tors and taking into a

ount all the small details (kernel behavior, 
ompiler versions and <SPAN class="ft1"></SPAN>ags, stati
 and dynami
 liking options, set of shared libraries used...) that need be taken into a

ount to write an e<SPAN class="ft1"></SPAN>e
tive exploit for a given target nowadays. Given the number of ta
ti
s available in the literature that work only on very spe
i<SPAN class="ft1"></SPAN>
 o

asions (su
h as spe
i<SPAN class="ft1"></SPAN>
 distributions), the exploitation strategies o<SPAN class="ft1"></SPAN>ered by this tool shall prove valuable to atta
kers (exploit writers) and software developers or system administrators alike ("is this vulnerability a<SPAN class="ft1"></SPAN>e
ting my system or software exploitable by the state of the art of exploitation theory on my parti
ular setup ?").</P>
<P class="p256 ft2">11 a
knowledgements</P>
<P class="p9 ft5">The author would like to thank in no parti
ular order #busti
ati, #so
ial, #grse
urity, #rux
on, #bla
kse
, THC/TESO, pipa
s, spender, twiz, bliss, silvio, andrewg, mer
y, gamma, bsdeamon, 
addis, izik, xort, redsand, sbz, deadbyte, the grugq, phil, emmanuel, msui
he, the Ha
kito Ergo Sum (HES) team, the HES Programming 
omitee, the HES speakers and friends, the /tmp/lab ha
kerspa
e, Mark Dowd, Meder Kydyraliev, the CBACert for their te
hni
al 
ontributions, ideas and peer reviews. The Tou
an System team, his family and his girlfriend, for their en
ouragements, and their patien
e.</P>
</DIV>
<DIV id="id30_2">
<P class="p10 ft0">30</P>
</DIV>
</DIV>
<DIV id="page_31">


<DIV id="id31_1">
<P class="p10 ft2">Referen
es</P>
<P class="p257 ft24"><SPAN class="ft24">1.</SPAN><SPAN class="ft26">PaXTeam: (http://pax.grse
urity.net/do
s/aslr.txt)</SPAN></P>
<P class="p165 ft3"><SPAN class="ft3">2.</SPAN><SPAN class="ft39">PaXTeam: (http://pax.grse
urity.net/do
s/noexe
.txt)</SPAN></P>
<P class="p165 ft3"><SPAN class="ft3">3.</SPAN><SPAN class="ft39">PaXTeam: (http://pax.grse
urity.net/)</SPAN></P>
<P class="p165 ft24"><SPAN class="ft24">4.</SPAN><SPAN class="ft26">AMD: (http://support.amd.
om/us/pro
essor_te
hdo
s/24593.pdf)</SPAN></P>
<P class="p165 ft3"><SPAN class="ft3">5.</SPAN><SPAN class="ft39">Drepper, U.: (Se
urity enhan
ements in red hat enterprise linux)</SPAN></P>
<P class="p165 ft3"><SPAN class="ft3">6.</SPAN><SPAN class="ft39">Jelinek, J.: </SPAN><NOBR>(http://g

.gnu.org/ml/g

-pat
hes/2004-09/msg02055.html)</NOBR></P>
<P class="p258 ft5"><SPAN class="ft5">7.</SPAN><SPAN class="ft38">BBSDaemon: Dynami
 program analysis and software exploitation, from the 
rash to the exploit 
ode. (Phra
k magazine)</SPAN></P>
<P class="p167 ft24"><SPAN class="ft24">8.</SPAN><SPAN class="ft26">Bania, P.: Spiderpig. Te
hni
al report (2008)</SPAN></P>
<P class="p259 ft3"><SPAN class="ft3">9.</SPAN><SPAN class="ft39">Cristian Cadar, Daniel Dunbar, D.E.: Klee: Unassisted and automati
 generation of </SPAN><NOBR>high-
overage</NOBR> tests for 
omplex systems programs. Te
hni
al report (2008)</P>
<P class="p10 ft24"><SPAN class="ft24">10.</SPAN><SPAN class="ft26">Thanassis Avgerinos, Sang Kil Cha, B.L.T.H., Brumley, D.: (Aeg: Automati
 exploit generation)</SPAN></P>
<P class="p10 ft3"><SPAN class="ft3">11.</SPAN><SPAN class="ft39">Henderson, R.: </SPAN><NOBR>(http://g

.gnu.org/ml/g

-pat
hes/2005-05/msg01193.html)</NOBR></P>
<P class="p10 ft24"><SPAN class="ft24">12.</SPAN><SPAN class="ft26">lo
al
ore, D..: (/bin/su exploit : </SPAN><NOBR>http://www.exploit-db.
om/exploits/209/)</NOBR></P>
<P class="p10 ft3"><SPAN class="ft3">13.</SPAN><SPAN class="ft39">Hertz: (at_exit() lo
al exploit)</SPAN></P>
<P class="p10 ft3"><SPAN class="ft3">14.</SPAN><SPAN class="ft39">Anonymous: Runtime pro
ess infe
tion. (Phra
k magazine)</SPAN></P>
<P class="p10 ft24"><SPAN class="ft24">15.</SPAN><SPAN class="ft26">Stealth: </SPAN><NOBR>(http://stealth.openwall.net/lo
al/inje
tso-0.52.tgz)</NOBR></P>
<P class="p10 ft3"><SPAN class="ft3">16.</SPAN><SPAN class="ft39">Brossard, J.: Opera : Sele
t size arbitrary null write, </SPAN><NOBR>tssa-2011-02,</NOBR> <NOBR>
ve-2011-1824</NOBR> (2011)</P>
<P class="p260 ft5"><SPAN class="ft5">17.</SPAN><SPAN class="ft38">Intel: Intel 64 and </SPAN><NOBR>ia-32</NOBR> ar
hite
tures software developer's manual. In: Volume 3A: System Pro- gramming Guide. (2008)</P>
<P class="p172 ft3"><SPAN class="ft3">18.</SPAN><SPAN class="ft39">van de Ven, A.: (Limiting bu</SPAN><SPAN class="ft1"></SPAN>er over<SPAN class="ft1"></SPAN>ows with exe
shield)</P>
<P class="p10 ft24"><SPAN class="ft24">19.</SPAN><SPAN class="ft26">Mark Daniel, Jake Honoro</SPAN><SPAN class="ft1"></SPAN>, C.M.: (Engineering heap over<SPAN class="ft1"></SPAN>ow exploits with javas
ript)</P>
<P class="p10 ft3"><SPAN class="ft3">20.</SPAN><SPAN class="ft39">Chen, Y.: (Using information leakage to avoid aslr+dep)</SPAN></P>
<P class="p10 ft2"><SPAN class="ft2">21.</SPAN><SPAN class="ft27">Vreugdenhil, P.: (Internet explorer 8 on windows 7 exploit form the pown2own 
ontest 2010)</SPAN></P>
</DIV>
<DIV id="id31_2">
<P class="p10 ft0">31</P>
</DIV>
</DIV>
</BODY>
</HTML>
